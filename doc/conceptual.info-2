This is conceptual.info, produced by makeinfo version 4.13 from
conceptual.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* coNCePTuaL: (conceptual).   A domain-specific language for network benchmarks
END-INFO-DIR-ENTRY

   This file describes the coNCePTuaL language and tool suite.

   Copyright (C) 2012, Los Alamos National Security, LLC


File: conceptual.info,  Node: Sending,  Next: Receiving,  Prev: Message specifications,  Up: Communication statements

4.4.2 Sending
-------------

The `SEND' statement is fundamental to CONCEPTUAL.  It is used to send
a multiple messages from multiple source tasks to multiple target
tasks.  The syntax is formally specified as follows:

<SEND_STMT>   ::=   <SOURCE_TASK>
                    [`ASYNCHRONOUSLY'] `SENDS'
                    <MESSAGE_SPEC>
                    `TO' [`UNSUSPECTING'] <TARGET_TASKS>
              |     <SOURCE_TASK>
                    [`ASYNCHRONOUSLY'] `SENDS'
                    <MESSAGE_SPEC>
                    `TO' <TARGET_TASKS>
                    `WHO RECEIVE IT'
                    <RECV_MESSAGE_SPEC>

<SOURCE_TASK> is described in *note Source tasks::; <MESSAGE_SPEC> and <RECV_MESSAGE_SPEC>
are described in *note Message specifications::; and, <TARGET_TASKS> is
described in *note Target tasks::.

   The `SEND' statement's simplest form, "<SOURCE_TASK> `SENDS' <MESSAGE_SPEC> `TO' <TARGET_TASKS>",
is fairly straightforward.  The following is a example:

     TASK 0 SENDS A 0 BYTE MESSAGE TO TASK 1

The only subtlety in the preceding statement is that it implicitly
causes task 1 to perform a corresponding receive.  This receive can be
suppressed by adding the keyword `UNSUSPECTING' before the <TARGET_TASKS>
description:

     TASK 0 SENDS A 0 BYTE MESSAGE TO UNSUSPECTING TASK 1

   Here are some further examples of valid <SEND_STMT>s:

   * `ALL TASKS SEND A 64 KILOBYTE MESSAGE TO TASK 0'

   * `TASK num_tasks-1 SENDS 5 53 BYTE PAGE ALIGNED MESSAGES TO ALL
     OTHER TASKS'

   * `TASKS upper SUCH THAT upper>=num_tasks/2 ASYNCHRONOUSLY SEND A 0
     BYTE MESSAGE TO TASK upper/2'

   * `TASKS nonzero SUCH THAT nonzero>0 SEND nonzero 1E3 BYTE MESSAGES
     TO UNSUSPECTING TASK 0'

   There are a number of attributes associated with every message
transmission:

   * synchronous vs. asynchronous operation

   * unique vs. recycled message buffers

   * unaligned vs. aligned vs. misaligned message buffers

   * no data touching vs. data touching vs. data verification

   * first-in, first-out vs. selective message ordering based on
     message tags

   * implicit vs. explicit message-buffer selection

   * explicit byte offsets into message buffers

A few of those appear in the preceding examples.

   When `UNSUSPECTING' is omitted, the implicit `RECEIVE' statement
normally inherits all of the attributes of the corresponding `SEND'.
However, the second form of a <SEND_STMT>, which contains a `WHO
RECEIVES IT' (or `WHO RECEIVES THEM') clause, enables the receiver's
attributes to be overridden on a per-attribute basis.  For instance,
consider the following `SEND' statement:

     TASK 0 SENDS A 1 MEGABYTE MESSAGE TO TASK 1 WHO RECEIVES IT
     ASYNCHRONOUSLY

The alternative sequence of statements that does not use RECEIVES IT
`WHO RECEIVES IT' is less straightforward to read because it splits a
single message transmission into two statements:

  1. `TASK 1 ASYNCHRONOUSLY RECEIVES A 1 MEGABYTE MESSAGE FROM TASK 0'

  2. `TASK 0 SENDS A 1 MEGABYTE MESSAGE TO UNSUSPECTING TASK 1'

   Some further examples of `WHO RECEIVES IT' follow:

     TASKS left SUCH THAT left IS EVEN SEND 5 2 KILOBYTE 64 BYTE ALIGNED
     MESSAGES TO TASKS left+1 WHO RECEIVE THEM AS UNALIGNED MESSAGES WITH
     DATA TOUCHING

     TASK num_tasks-1 ASYNCHRONOUSLY SENDS A 1E5 BYTE MESSAGE WITH
     VERIFICATION TO TASK 0 WHO RECEIVES IT SYNCHRONOUSLY

     TASK leaf SUCH THAT KNOMIAL_CHILDREN(leaf,2)=0 SENDS A UNIQUE 1536
     BYTE MESSAGE WITH DATA TOUCHING TO TASK KNOMIAL_PARENT(leaf,2) WHO
     RECEIVES IT ASYNCHRONOUSLY AS A NONUNIQUE QUADWORD ALIGNED MESSAGE
     WITHOUT DATA TOUCHING INTO BUFFER KNOMIAL_PARENT(leaf,2)

   One subtlety of the `SEND' statement when used without `UNSUSPECTING'
involves the orderings of the sends and receives.  The rule is that
receives are posted before sends.  Furthermore, <RESTRICTED_IDENT>s
(*note Restricted identifiers::) are evaluated in order from 0
to NUM_TASKS-1.  The implication is that a statement such as `TASKS ev
SUCH THAT ev IS EVEN /\ ev<6 SEND A 4 WORD MESSAGE TO TASK ev+2' is
exactly equivalent to the following ordered sequence of statements
(assuming NUM_TASKS >= 5):

  1. `TASK 2 RECEIVES A 4 WORD MESSAGE FROM TASK 0'

  2. `TASK 4 RECEIVES A 4 WORD MESSAGE FROM TASK 2'

  3. `TASK 6 RECEIVES A 4 WORD MESSAGE FROM TASK 4'

  4. `TASK 0 SENDS A 4 WORD MESSAGE TO UNSUSPECTING TASK 2'

  5. `TASK 2 SENDS A 4 WORD MESSAGE TO UNSUSPECTING TASK 4'

  6. `TASK 4 SENDS A 4 WORD MESSAGE TO UNSUSPECTING TASK 6'

(The `RECEIVE' statement is described in *note Receiving::.)

   If the above sequence were executed, tasks 2, 4, and 6 would
immediately block on their receives (steps 1-3).  Task 0 would awaken
task 2 by sending it a message (step 4).  Then, task 2 would be able to
continue to step 5 at which point it would send a message to task 4.
Task 4 would then finally be able to send a message to task 6 (step 6).
Hence, even though the original CONCEPTUAL statement encapsulates
multiple communication operations, the component communications proceed
sequentially because of data dependences and because the operations are
blocking.

   As another example of send/receive ordering, consider the statement,
`TASKS x SUCH THAT x IS IN {1,4,5} SEND A 768 BYTE MESSAGE FROM 4
DOUBLEWORDS INTO THE DEFAULT BUFFER TO TASKS y SUCH THAT y IS IN
{6,2,3}'.  This statement causes nine messages to be sent and received
and in the following order: 1 => 2, 1 => 3, 1 => 6, 4 => 2, 4 => 3,
4 => 6, 5 => 2, 5 => 3, 5 => 6.  The reason that task 6 receives from
each sender _after_ tasks 2 and 3 relates to the comment above that <RESTRICTED_IDENT>s
are evaluated in order from 0 to NUM_TASKS-1.  One can therefore think
of the preceding CONCEPTUAL statement as being implemented with the
following pseudocode:

     for s := 0 to num_tasks-1 do
       if s is in {1, 4, 5} then
         for r := 0 to num_tasks-1 do
           if r is in {6, 2, 3} then
             r receives from s
     for s := 0 to num_tasks-1 do
       if s is in {1, 4, 5} then
         for r := 0 to num_tasks-1 do
           if r is in {6, 2, 3} then
             s sends to r


File: conceptual.info,  Node: Receiving,  Next: Awaiting completion,  Prev: Sending,  Up: Communication statements

4.4.3 Receiving
---------------

*note Sending::, mentioned the <SEND_STMT>'s `UNSUSPECTING' keyword,
which specifies that the targets should not implicitly perform a
receive operation.  Because every send must have a matching receive,
CONCEPTUAL offers a `RECEIVE' statement that explicitly receives a set
of messages.  A <RECEIVE_STMT> is much like a <SEND_STMT> (*note
Sending::) with the <SOURCE_TASK> and <TARGET_TASKS> in the reverse
order:

<RECEIVE_STMT>   ::=   <TARGET_TASKS>
                       [`ASYNCHRONOUSLY'] `RECEIVE'
                       <MESSAGE_SPEC>
                       `FROM' <SOURCE_TASK>

<TARGET_TASKS> is described in *note Target tasks::; <MESSAGE_SPEC> is
described in *note Message specifications::; and, <SOURCE_TASK> is
described in *note Source tasks::.

   Like other statements that contain both a <SOURCE_TASK> and a <TARGET_TASKS>,
the `RECEIVE' statement propagates all variables declared by the <SOURCE_TASK>
to the <TARGET_TASKS>, as in

     TASKS src-1 RECEIVE A 1 MEGABYTE MESSAGE FROM ALL TASKS src.

However, the `RECEIVE' statement is unique among CONCEPTUAL statements
in that it can alternatively propagate all variables declared by the <TARGET_TASKS>
to the <SOURCE_TASK>, as in

     ALL TASKS dst RECEIVE A 1 MEGABYTE MESSAGE FROM TASKS dst+1.

The `RECEIVE' statement automatically determines the direction in which
variables should be propagated.  If the direction cannot unambiguously
be determined, the CONCEPTUAL compiler aborts with an error message.
For example, the `RECEIVE' statement in the following code is ambiguous
because the `bbb' in the expression `aaa < bbb' can refer to either the
one in the `LET' statement or the one in the `TASKS bbb SUCH THAT bbb >
3' expression:

     LET bbb BE 5 WHILE {
       TASKS aaa SUCH THAT aaa < bbb RECEIVE A MESSAGE FROM TASKS bbb SUCH
       THAT bbb > 3 THEN
       TASKS ccc SUCH THAT ccc > 3 SEND A MESSAGE TO UNSUSPECTING TASKS
       ddd SUCH THAT ddd < ccc
     }

   For each message sent via a `SEND'...`TO UNSUSPECTING' statement
there must be a `RECEIVE' statement that receives a message of the same
size.  The <TARGET_TASKS>'s <MESSAGE_SPEC> can, however, specify
different values for message uniqueness, message alignment, and data
touching.  In addition, the source and target do not need to agree on
the use of the `ASYNCHRONOUSLY' keyword.  The only restriction is that `WITH
VERIFICATION' will return spurious results if used by the target but
not by the source.  Hence, the following <SEND_STMT> and <RECEIVE_STMT>
correctly match each other:

     TASK 0 SENDS 3 4 KILOBYTE MESSAGES TO UNSUSPECTING TASK 1

     TASK 1 ASYNCHRONOUSLY RECEIVES 3 UNIQUE 4 KILOBYTE 48 BYTE ALIGNED
     MESSAGES WITH DATA TOUCHING FROM TASK 0.

   In general, it is better to use a single `SEND' statement with a `WHO
RECEIVES IT' clause (*note Sending::) than a `RECEIVE' plus a matching `SEND'...`TO
UNSUSPECTING'; the former is less error-prone than the latter.
However, the latter is useful for programs in which a set of receives
is posted, then the tasks perform various communication, computation,
and synchronization operations, and--towards the end of the
program--the matching sends are posted.  That sort of split-phase
structure requires separate `SEND' and `RECEIVE' statements.


File: conceptual.info,  Node: Awaiting completion,  Next: Multicasting,  Prev: Receiving,  Up: Communication statements

4.4.4 Awaiting completion
-------------------------

When a message is sent or received asynchronously it must eventually be
"completed".  In some messaging layers, asynchronous messages are not
even sent or received until completion time.  CONCEPTUAL provides the
following statement for completing messages that were send/received
asynchronously:

<WAIT_STMT>   ::=   <SOURCE_TASK>
                    `AWAITS COMPLETION'

That is, a <WAIT_STMT> simply specifies the set of tasks that should
block until all of their pending communications complete.  <SOURCE_TASK>
is as defined in *note Source tasks::.  Note that a <WAIT_STMT> blocks
until _all_ pending communications complete.  CONCEPTUAL does not
provide finer-grained control over completions.  It is safe, however,
for a task to `AWAIT COMPLETION' even if it has no asynchronous messages
pending.


File: conceptual.info,  Node: Multicasting,  Next: Reducing,  Prev: Awaiting completion,  Up: Communication statements

4.4.5 Multicasting
------------------

Although a single <SEND_STMT> (*note Sending::) can specify multiple
messages at once, these messages are sent one at a time.
"Multicasting" is a form of collective communication in which a set of
tasks collaborates to deliver a message from a source to multiple
targets.  With many messaging layers, multicasting a message to N tasks
is more efficient than sending a sequence of N individual messages.
CONCEPTUAL supports multicasting as follows:

<MCAST_STMT>    ::=   <SOURCE_TASK>
                      [`ASYNCHRONOUSLY'] `MULTICASTS'
                      <MESSAGE_SPEC>
                      `TO' <TARGET_TASKS>

   Unlike <SEND_STMT>s, <MCAST_STMT>s do not support the `UNSUSPECTING'
keyword.  This is because `MULTICASTS' is a collective operation: all
parties are active participants in delivering messages to the <TARGET_TASKS>.

   <SOURCE_TASK> (*note Source tasks::) and <TARGET_TASKS> (*note
Target tasks::) can be either disjoint or overlapping sets.  That is,
either of the following is legal:

     TASK 0 MULTICASTS A 16 BYTE MESSAGE TO TASKS recip SUCH THAT recip<4
     TASK 0 MULTICASTS A 16 BYTE MESSAGE TO TASKS recip SUCH THAT recip>=4

Note that in the first <MCAST_STMT>, task 0 both sends and receives a
message, while in the second <MCAST_STMT>, task 0 sends but does not
receive.

   The `MULTICASTS' statement supports not only traditional one-to-many
multicasting as shown in the preceding example but also many-to-many
multicasting--and the less interesting but still valid many-to-one and
one-to-one multicasting.  The constituent pairs of communicating tasks
are identical to those induced by the `SENDS' statement (*note
Sending::).  For example, the statement

     TASKS s SUCH THAT s<3 MULTICAST A 1 KILOBYTE MESSAGE TO TASKS s SUCH
     THAT s>6

performs the collective analogue of

     TASKS s SUCH THAT s<3 SEND A 1 KILOBYTE MESSAGE TO TASKS s SUCH
     THAT s>6

Specifically, task 0 will send a message to each of tasks 7, 8, 9, ...;
task 1 will send a message to each of tasks 7, 8, 9, ...; and task 2
will send a message to each of tasks 7, 8, 9, ...


File: conceptual.info,  Node: Reducing,  Next: Synchronizing,  Prev: Multicasting,  Up: Communication statements

4.4.6 Reducing
--------------

A reduction operation is, in a sense, a complementary operation to a
multicast (*note Multicasting::).  While a multicast delivers a message
from one source to multiple targets, a reduction combines messages from
multiple sources (by applying a commutative/associative operator to
corresponding elements) to a single target.  Reduction is a collective
operation: all parties collaborate to calculate the reduced value(s).
As an example, if tasks 0, 1, and 2 collectively reduce the messages
{5, 1}, {2, 7}, and {3, 4} to task 2 using the "+" operator, then
task 2 will receive the message {10, 12}.  In fact, CONCEPTUAL's
implementation of reductions also supports reductions to multiple
targets with each target receiving a copy of the reduced value.

   The following grammatical rules define CONCEPTUAL's many-to-many and
many-to-one reduction facilities:

<REDUCE_STMT>   ::=   <SOURCE_TASK>
                      `REDUCES'
                      <REDUCE_MESSAGE_SPEC>
                      `TO' <SOURCE_TASK>
                      [`WHO RECEIVES THE RESULT' <REDUCE_TARGET_MESSAGE_SPEC>]
                |     <SOURCE_TASK>
                      `REDUCES'
                      <REDUCE_MESSAGE_SPEC>
                      [`TO' <REDUCE_MESSAGE_SPEC>]

   <REDUCE_MESSAGE_SPEC> is defined in *note Message specifications::.
Both the data providers and data receivers are specified as <SOURCE_TASK>
nonterminals (*note Source tasks::).  This design enables any set of
tasks to provide the data to reduce and any disjoint or overlapping set
of tasks to receive the reduced data.  As with all communication in
CONCEPTUAL, message contents are opaque.  Furthermore, the grammar does
not currently enable the programmer to specify the
commutative/associative operator to use.

   A simple many-to-one reduction can be expressed in CONCEPTUAL with
`ALL TASKS REDUCE 5 DOUBLEWORDS TO TASK 0'.  Note that the definition
of <REDUCE_MESSAGE_SPEC> and <REDUCE_TARGET_MESSAGE_SPEC> (*note
Message specifications::) supports reductions only of `INTEGER's and `DOUBLEWORD's,
not arbitrary <DATA_TYPE> values.  Omitting the optional ``TO' <REDUCE_MESSAGE_SPEC>',
as in `TASKS rt SUCH THAT 3 DIVIDES rt REDUCE AN INTEGER', specifies
that all tasks performing the reduction will receive a copy of the
reduced value.  The sources and targets can also be designated
explicitly as in `TASKS xyz SUCH THAT xyz<num_tasks/2 REDUCE 100
DOUBLEWORDS TO TASKS xyz+num_tasks/4'.  When that code is run with
8 tasks, tasks 0-3 reduce 100 doublewords (800 bytes) apiece and
tasks 2-5 each receive identical copies of the 100 doublewords of
reduced data.

   Message data used with `REDUCES' can be transfered DATA TOUCHING
`WITH DATA TOUCHING' (but not `WITH VERIFICATION'); data alignment can
be specified; and, messages buffers can be named explicitly.  The
following example represents fairly complex many-to-many usage of `REDUCES':

     TASKS rsrc SUCH THAT rsrc IS EVEN REDUCE 32 64-BYTE-ALIGNED INTEGERS
     WITH DATA TOUCHING FROM BUFFER 2 TO TASKS rtarg SUCH THAT
     rtarg<num_tasks/4 \/ rtarg>(3*num_tasks)/4 WHO RECEIVE THE RESULT AS
     32 UNIQUE PAGE-ALIGNED INTEGERS WITHOUT DATA TOUCHING.


File: conceptual.info,  Node: Synchronizing,  Prev: Reducing,  Up: Communication statements

4.4.7 Synchronizing
-------------------

CONCEPTUAL enables sets of tasks to perform "barrier synchronization".
The semantics are that no task can finish synchronizing until all tasks
have started synchronizing.  The syntax is as follows:

<SYNC_STMT>   ::=   <SOURCE_TASK>
                    `SYNCHRONIZES'

   A <SYNC_STMT> can be used to ensure that one set of statements has
completed before beginning another set.  For example, a CONCEPTUAL
program might have a set of tasks post a series of asynchronous
receives (*note Receiving::), then make `ALL TASKS SYNCHRONIZE' before
having another set of tasks perform the corresponding `UNSUSPECTING'
sends (*note Sending::).  This procedure ensures that all of the target
tasks are ready to receive before the source tasks start sending to
them.


File: conceptual.info,  Node: I/O statements,  Next: Counter and timer statements,  Prev: Communication statements,  Up: Grammar

4.5 I/O statements
==================

CONCEPTUAL provides two statements for presenting information.  One
statement writes simple messages to the standard output device and is
intended to be used for providing status information during the run of
a program.  The other statement provides a powerful mechanism for
storing performance and correctness data to a log file.

* Menu:

* Utilizing log-file comments::  Treating log-file comments as a database
* Writing to standard output::  Displaying status messages
* Writing to a log file::       Storing test results


File: conceptual.info,  Node: Utilizing log-file comments,  Next: Writing to standard output,  Prev: I/O statements,  Up: I/O statements

4.5.1 Utilizing log-file comments
---------------------------------

<OUTPUT_STMT>s and <LOG_STMT>s have limited access to the <KEY:VALUE>
pairs that are written as comments at the top of every log file as
shown in *note Log-file format::.  Given a key, KEY, the string
expression `THE VALUE OF KEY' represents the value associated with that
key or the empty string if KEY does not appear in the log-file comments:

<STRING_OR_LOG_COMMENT>   ::=   <STRING>
                          |     `THE VALUE OF' <STRING>

That is, `"CPU frequency"' means the literal string "CPU frequency"
while `THE VALUE OF "CPU frequency"' translates to a string like
"1300000000 Hz (1.3 GHz)".  Environment variables are also considered
keys and are therefore acceptable input to a VALUE OF `THE VALUE OF'
construct.


File: conceptual.info,  Node: Writing to standard output,  Next: Writing to a log file,  Prev: Utilizing log-file comments,  Up: I/O statements

4.5.2 Writing to standard output
--------------------------------

CONCEPTUAL's `OUTPUT' keyword is used to write a message from one or
more source tasks (*note Source tasks::) to the standard output device.
This is useful for providing progress reports during the execution of
long-running CONCEPTUAL programs.  An <OUTPUT_STMT> looks like this:

<OUTPUT_STMT>   ::=   <SOURCE_TASK>
                      `OUTPUTS'
                      <EXPR> | <STRING_OR_LOG_COMMENT>
                      [`AND'   <EXPR> | <STRING_OR_LOG_COMMENT>]*

   The following are some sample <OUTPUT_STMT>s:

     TASK 0 OUTPUTS "Hello, world!"

     TASKS nr SUCH THAT nr>0 OUTPUT nr AND "'s parent is " AND nr>>1 AND
     " and its children are " AND nr<<1 AND " and " AND nr<<1+1

     ALL TASKS me OUTPUT "Task " AND me AND " is running on host " AND THE
     VALUE OF "Host name" AND " and plans to send to task " AND (me+1) MOD
     num_tasks

   `OUTPUT' does not implicitly output spaces between terms.  Hence,
`OUTPUT "Yes" AND "No"' will output "YesNo", not "Yes No".  Although it
is unlikely that a program would ever need to output two arithmetic
expressions with no intervening text, an empty string can be used for
this purpose: `OUTPUT 6 AND "" AND 3'.

   An <OUTPUT_STMT> implicitly outputs a newline character at the end.
Additional newline characters can be output by embedding `\n' in a
string.  (*note Primitives::.)  CONCEPTUAL does not provide a means for
suppressing the newline, however.


File: conceptual.info,  Node: Writing to a log file,  Prev: Writing to standard output,  Up: I/O statements

4.5.3 Writing to a log file
---------------------------

After performing a network correctness or performance test it is almost
always desirable to store the results in a file.  CONCEPTUAL has
language support for writing tabular data to a log file.  The <LOG_STMT>
command does the bulk of the work:

<LOG_STMT>   ::=   <SOURCE_TASK>
                   `LOGS'
                   <AGGR_EXPR> `AS' <STRING_OR_LOG_COMMENT>
                   [`AND' <AGGR_EXPR> `AS' <STRING_OR_LOG_COMMENT>]*

   The idea behind a <LOG_STMT> is that a set of source tasks (*note
Source tasks::) log an aggregate expression (*note Aggregate
expressions::) to a log file under the column heading <STRING_OR_LOG_COMMENT>.
Each task individually maintains a separately named log file so there
is no ambiguity over which task wrote which entries.

   Each (static) `LOGS' statement in a CONCEPTUAL program specifies one
or more columns of the log file.  Every dynamic execution of a `LOGS'
statement writes a single row to the log file.  A single `LOGS'
statement should suffice for most CONCEPTUAL programs.

   The following are some examples of <LOG_STMT>s:

     ALL TASKS LOG bit_errors AS "Bit errors"

     TASK 0 LOGS THE msgsize AS "Bytes" AND
                 THE MEDIAN OF (1E6*bytes_sent)/(1M*elapsed_usecs) AS "MB/s"

The first example produces a log file like the following:

     "Bit errors"
     "(all data)"
     3

The second example produces a log file like this:

     "Bytes","MB/s"
     "(only value)","(median)"
     65536,179.9416266

Note that in each log file, the CONCEPTUAL run-time system writes two
rows of column headers for each column.  The first row contains <STRING_OR_LOG_COMMENT>
as is.  The second row describes the <AGGR_FUNC> (*note Aggregate
functions::) used to aggregate the data.  One or more rows of data
follow.

   Assume that the second <LOG_STMT> presented above appears within a
loop (*note Iterating::).  It is therefore important to include the `THE'
keyword before `msgsize' to assert that the expression `msgsize' is
constant across invocations of the <LOG_STMT> and that, consequently,
only a single row of data should be written to the log file.  Using
`msgsize' without the `THE' would produce a column of data with one row
per <LOG_STMT> invocation:

     "Bytes","MB/s"
     "(all data)","(median)"
     65536,179.9416266
     65536,
     65536,
     65536,
     65536,
          .
          .
          .

   The rules that determine how `LOGS' statements produce rows and
columns of a log file are presented below:

  1. Each _static_ `LOGS' statement (and `AND' clause within a `LOGS'
     statement) in a program produces a unique column.

  2. Each _dynamic_ execution of a `LOGS' statement appends a row to
     the column(s) it describes.

  3. Each top-level complex statement (*note Complete programs::)
     produces a new table in the log file.

   Note that the choice of column name is inconsequential for
determining what columns are written to the log file:

     TASK 0 LOGS 314/100 AS "Pi" AND 22/7 AS "Pi"

     "Pi","Pi"
     "(all data)","(all data)"
     3.14,3.142857143

* Menu:

* Computing aggregates::        Forcing aggregates to compute a result


File: conceptual.info,  Node: Computing aggregates,  Prev: Writing to a log file,  Up: Writing to a log file

Computing aggregates
....................

What if `msgsize' takes on a number of values throughout the execution
of the program and for each value a number of runs is performed?  How
would one log the median of each set of data?  Using `THE msgsize'
won't work because the message size is not constant.  Using `msgsize'
alone won't work either because CONCEPTUAL would then take the median
of the times gathered across _all_ message sizes, which is undesirable.
The solution is for the program to specify explicitly when aggregate
functions (`MEDIAN' and all of the other functions listed in *note
Aggregate functions::) compute a value:

<FLUSH_STMT>   ::=   <SOURCE_TASK>
                     `COMPUTES AGGREGATES'

   The intention is that an inner loop might `LOG' data after every
iteration and an outer loop would `COMPUTE AGGREGATES' after each
iteration.


File: conceptual.info,  Node: Counter and timer statements,  Next: Complex statements,  Prev: I/O statements,  Up: Grammar

4.6 Counter and timer statements
================================

Critical to any performance or correctness test is the ability to
specify which operations represent the test itself and should be
measured and which are setup or other uninteresting operations and
should not.  CONCEPTUAL automatically maintains a number of
"counters"--variables that represent message counts, byte counts,
bit-error counts, and elapsed time.  The complete list is presented in
*note Predeclared variables::.

   Normally, a CONCEPTUAL program performs some setup operations, `RESETS
ITS COUNTERS' to zero, executes a communication pattern, and logs some
function of the resulting changes in counter values (*note Writing to a
log file::).  If additional setup work needs to be performed during an
experiment, a program can COUNTERS `STORE ITS COUNTERS', perform any
arbitrarily costly operations, ITS COUNTERS `RESTORE ITS COUNTERS', and
continue the experiment as if those operations never happened.

   Some CONCEPTUAL statements implicitly store and restore counters.
For example, the `LOGS' statement *note Writing to a log file::) takes
up no time from the program's perspective, and counted loops (*note
Counted loops::) bracket any warmup repetitions and post-warmup
synchronizations between a counter store and restore so no delays, bit
errors, or messaging operations contribute to the totals measured by
the experiment.

* Menu:

* Resetting counters::          Clearing message, byte, and time tallies
* Storing counter values::      Storing message, byte, and time tallies
* Restoring counter values::    Restoring stored message, byte, and time tallies


File: conceptual.info,  Node: Resetting counters,  Next: Storing counter values,  Prev: Counter and timer statements,  Up: Counter and timer statements

4.6.1 Resetting counters
------------------------

At the start of an experiment, after all setup processing has
completed, all tasks that will eventually log measurement results
should zero out their counters:

<RESET_STMT>   ::=   <SOURCE_TASK>
                     `RESETS ITS COUNTERS'

   Hence, writing `ALL TASKS RESET THEIR COUNTERS' causes each task to
reset all of the variables listed in *note Predeclared
variables::--with the exception of `num_tasks'--to zero.  Note that
`ITS' and `THEIR', like `RESET' and `RESETS', are considered synonyms
(*note Primitives::).


File: conceptual.info,  Node: Storing counter values,  Next: Restoring counter values,  Prev: Resetting counters,  Up: Counter and timer statements

4.6.2 Storing counter values
----------------------------

A program can store the current values of all of the variables listed
in *note Predeclared variables:: as follows:

<STORE_STMT>   ::=   <SOURCE_TASK>
                     `STORES ITS COUNTERS'

   For example, writing `TASK 0 STORES ITS COUNTERS' causes task 0 to
store the current values of `elapsed_usecs', `total_msgs', `bit_errors',
etc.  The values are not modified.  Note that `ITS' and `THEIR', like
`STORE' and `STORES', are considered synonyms (*note Primitives::).


File: conceptual.info,  Node: Restoring counter values,  Prev: Storing counter values,  Up: Counter and timer statements

4.6.3 Restoring counter values
------------------------------

Counters can be restored to their most recently saved values with a <RESTORE_STMT>:

<RESTORE_STMT>   ::=   <SOURCE_TASK>
                       `RESTORES ITS COUNTERS'

   For example, writing `TASKS t SUCH THAT 3 DIVIDES t RESTORE THEIR
COUNTERS' causes every third task to replace `elapsed_usecs', `total_msgs', `bit_errors',
etc. with the values stored by a corresponding <STORE_STMT> (*note
Storing counter values::).  Note that `ITS' and `THEIR', like `RESTORE'
and `RESTORES', are considered synonyms (*note Primitives::).

   An important feature of `STORES' and `RESTORES' is that they can be
nested.  That is, each `STORE' pushes a set of counter values on a
stack, and each `RESTORE' pops a set of counter values from the stack.
Consequently, one can write code like the following:

     ALL TASKS RESET THEIR COUNTERS THEN                                 #  1
     ALL TASKS COMPUTE FOR 2 SECONDS THEN                                #  2
     ALL TASKS STORE THEIR COUNTERS THEN                                 #  3
       ALL TASKS COMPUTE FOR 5 SECONDS THEN                              #  4
       ALL TASKS STORE THEIR COUNTERS THEN                               #  5
         ALL TASKS COMPUTE FOR 9 SECONDS THEN                            #  6
         ALL TASKS LOG ROUND(elapsed_usecs/1E6) AS "Should be 16" THEN   #  7
       ALL TASKS RESTORE THEIR COUNTERS THEN                             #  8
       ALL TASKS LOG ROUND(elapsed_usecs/1E6) AS "Should be 7" THEN      #  9
       ALL TASKS STORE THEIR COUNTERS THEN                               # 10
         ALL TASKS COMPUTE FOR 1 SECOND THEN                             # 11
         ALL TASKS LOG ROUND(elapsed_usecs/1E6) AS "Should be 8" THEN    # 12
       ALL TASKS RESTORE THEIR COUNTERS THEN                             # 13
       ALL TASKS LOG ROUND(elapsed_usecs/1E6) AS "Should be 7" THEN      # 14
       ALL TASKS RESTORE THEIR COUNTERS THEN                             # 15
     ALL TASKS LOG ROUND(elapsed_usecs/1E6) AS "Should be 2".            # 16

   Indentation is used in the above to clarify which `RESTORE'
operations match which `STORE' operations.  The first `STORE' statement
(line 3) occurs after 2 seconds have elapsed.  The second `STORE'
statement (line 5) occurs after 2+5=7 seconds have elapsed.  When the `LOG'
statement in line 7 is executed, it reports that 2+5+9=16 seconds have
elapsed.  The `RESTORE' statement in line 8 then "winds back the clock"
to the previous `STORE' statement, the one in line 5.  The next `LOG'
statement (line 9) executes as if lines 5-8 never ran and therefore
reports that only 2+5=7 seconds have elapsed.  The `LOG' statement in
line 12 sees an additional second of elapsed time due to line 11's `COMPUTE'
statement, for a total of 2+5+1=8 seconds.  However, the `RESTORE' in
line 13 makes it as if that `COMPUTE' never happened.  Consequently,
the `LOG' statement in line 14 reports that only 2+5=7 seconds have
elapsed.  Finally, the `RESTORE' in line 15 sets the timer to the value
it had all the way back at line 3.  The final `LOG' statement (line 16)
therefore reports that only 2 seconds have elapsed because line 2
contains the only `COMPUTE' statement whose execution time has not been
discarded.

   Because the `interpret' backend and those derived from it use
logical time instead of physical time, the code listed above will
report all zeroes.  Replacing `ROUND(elapsed_usecs/1E6)' with just
`elapsed_usecs' will log the logical times {6,5,8,7,3}.  That is, the `LOG'
statement in line 7 sees six events after the initial `RESET';(1) the `LOG'
statement in line 9 sees only five events after the `RESET'
(corresponding to lines 2, 3, 4, 5, and 9); and so forth up to the final `LOG'
statement, which sees only three events: those produced by lines 2, 3,
and 16.

   A program that calls `RESTORE' more times than it calls `STORE' will
abort with a fatal run-time error.

   ---------- Footnotes ----------

   (1) Each statement in the example corresponds to a single event and
therefore counts as one unit of time.


File: conceptual.info,  Node: Complex statements,  Next: Other statements,  Prev: Counter and timer statements,  Up: Grammar

4.7 Complex statements
======================

The CONCEPTUAL statements presented in *note Communication statements::,
*note I/O statements::, and *note Other statements:: are all known as
"simple statements".  This section expands upon the statements already
introduced by presenting "complex statements".  In its most basic form,
a <COMPLEX_STMT> is just a <SIMPLE_STMT>.  However, the primary purpose
of a <COMPLEX_STMT> is to juxtapose simple statements and other complex
statements into more expressive forms.

   Complex statements take the following form:

<COMPLEX_STMT>   ::=   <SIMPLE_STMT> [`THEN' <COMPLEX_STMT>]

   The constituent simple statements include `FOR' loops, `LET'
bindings, `IF' conditionals, grouping constructs, and all of the
statements introduced in *note Communication statements::, *note I/O
statements::, and *note Other statements:::

<SIMPLE_STMT>   ::=   `FOR' <EXPR> `REPETITIONS'   [`PLUS' <EXPR> `WARMUP' `REPETITIONS'
                       [`AND A SYNCHRONIZATION']]   <SIMPLE_STMT>
                |      `FOR EACH' <IDENT> `IN' <RANGE>   [`,' <RANGE>]* <SIMPLE_STMT>
                |      `FOR' <EXPR> <TIME_UNIT> <SIMPLE_STMT>
                |      `LET' <LET_BINDING> [`AND' <LET_BINDING>]*   `WHILE'
                      <SIMPLE_STMT>
                |      `IF' <REL_EXPR> `THEN' <SIMPLE_STMT>   [`OTHERWISE'
                      <SIMPLE_STMT>]
                |     `{' [<COMPLEX_STMT>] `}'
                |     <SEND_STMT>
                |     <RECEIVE_STMT>
                |     <WAIT_STMT>
                |     <MCAST_STMT>
                |     <REDUCE_STMT>
                |     <SYNC_STMT>
                |     <OUTPUT_STMT>
                |     <LOG_STMT>
                |     <FLUSH_STMT>
                |     <RESET_STMT>
                |     <STORE_STMT>
                |     <RESTORE_STMT>
                |     <ASSERT_STMT>
                |     <DELAY_STMT>
                |     <TOUCH_STMT>
                |     <TOUCH_BUFFER_STMT>
                |     <PROCESSOR_STMT>
                |     <BACKEND_STMT>

   The remainder of this section describes in turn the `THEN' construct
and each of the just-introduced <SIMPLE_STMT> types.

* Menu:

* Combining statements::        Performing multiple statements in sequence
* Iterating::                   Performing a statement multiple times
* Binding variables::           Lending values to variables
* Conditional execution::       Executing statements only if a condition is met
* Grouping::                    Treating multiple statements as one


File: conceptual.info,  Node: Combining statements,  Next: Iterating,  Prev: Complex statements,  Up: Complex statements

4.7.1 Combining statements
--------------------------

The `THEN' keyword separates statements that are to be performed
sequentially.  For example, a simple ping-pong communication can be
expressed as follows:

     ALL TASKS RESET ALL COUNTERS THEN
     TASK 0 SENDS A 0 BYTE MESSAGE TO TASK 1 THEN
     TASK 1 SENDS A 0 BYTE MESSAGE TO TASK 0 THEN
     TASK 0 LOGS elapsed_usecs/2 AS "One-way latency"

   There is no implicit intertask synchronization across `THEN'
statements.  Consequently, the two communications specified in the
following statement will be performed concurrently:

     TASK 0 ASYNCHRONOUSLY SENDS AN 8 KILOBYTE MESSAGE TO TASK 1 THEN
     TASK 1 ASYNCHRONOUSLY SENDS AN 8 KILOBYTE MESSAGE TO TASK 0 THEN
     ALL TASKS AWAIT COMPLETION


File: conceptual.info,  Node: Iterating,  Next: Binding variables,  Prev: Combining statements,  Up: Complex statements

4.7.2 Iterating
---------------

CONCEPTUAL provides a variety of looping constructs designed to
repeatedly execute a <SIMPLE_STMT>.

* Menu:

* Counted loops::               Iterating for a given number of iterations
* Range loops::                 Iterating over lists of numbers
* Timed loops::                 Iterating for a given length of time


File: conceptual.info,  Node: Counted loops,  Next: Range loops,  Prev: Iterating,  Up: Iterating

Counted loops
.............

The simplest form of iteration in CONCEPTUAL repeats a <SIMPLE_STMT> a
given number of times.  The syntax is simply "`FOR' <EXPR> `REPETITIONS' <SIMPLE_STMT>".
As could be expected, the <EXPR> term (*note Arithmetic expressions::)
specifies the number of repetitions to perform.  Hence, the following <SIMPLE_STMT>
outputs the phrase "I will not talk in class" 100 times:

     FOR 100 REPETITIONS ALL TASKS OUTPUT "I will not talk in class."

   `FOR'...`REPETITIONS' can optionally specify a number of "warmup"
repetitions to perform in addition to the base number of repetitions.
The syntax is "`FOR' <EXPR> `REPETITIONS' `PLUS' <EXPR> REPETITIONS
`WARMUP REPETITIONS' <SIMPLE_STMT>".  During warmup repetitions, the `OUTPUTS'
statement (*note Writing to standard output::), the `LOGS' statement
(*note Writing to a log file::), and the `COMPUTES AGGREGATES'
statement (*note Computing aggregates::) are all suppressed (i.e., they
have no effect) and none of the special variables predeclared by
CONCEPTUAL (*note Predeclared variables::) are updated.  Many
benchmarks synchronize all tasks after performing a set of warmup
repetitions.  This behavior can be expressed conveniently as part of a
CONCEPTUAL `FOR' loop by appending the SYNCHRONIZATION `AND A
SYNCHRONIZATION' clause:

     FOR 1000 REPETITIONS PLUS 3 WARMUP REPETITIONS AND A SYNCHRONIZATION
     TASK 0 MULTICASTS A 1 MEGABYTE MESSAGE TO ALL OTHER TASKS

CONCEPTUAL also provides a separate `SYNCHRONIZES' statement.  This is
described in *note Synchronizing::.

   The importance of performing warmup repetitions is that many
communication layers give atypically poor performance on the first few
transmissions.  This may be because the messages miss in the cache;
because the communication layer needs to establish connections between
pairs of communicating tasks; or, because the operating system needs to
"register" message buffers with the network interface.  Regardless of
the reason, specifying warmup repetitions helps make performance
measurements less variable.


File: conceptual.info,  Node: Range loops,  Next: Timed loops,  Prev: Counted loops,  Up: Iterating

Range loops
...........

Range loops are CONCEPTUAL's most powerful looping construct.  Unlike
the counted-loop construct presented in *note Counted loops::, a range
loop binds a variable to a different value on each iteration.  Range
loops have the following syntax:

        `FOR EACH' <IDENT>
        `IN' <RANGE> [`,' <RANGE>]*
        <SIMPLE_STMT>

   A <RANGE> represents a range expression.  Range expressions are
described in *note Range expressions::.  In short, a range expression
specifies a list of values by explicit enumeration, numeric
progression, or predicated combinations of other range expressions.
For a range loop, CONCEPTUAL successively binds a specified variable to
each <EXPR> in each <RANGE> and evaluates the given <SIMPLE_STMT>.

   The following are some examples of the `FOR EACH' statement from
simplest to most elaborate.  Each example uses `i' as the loop variable
and `TASK 0 OUTPUTS i' as the loop body.  The output from each example
is shown with a "-|" symbol preceding each line.

     FOR EACH i IN {8, 7, 5, 4, 5} TASK 0 OUTPUTS i
     -| 8
     -| 7
     -| 5
     -| 4
     -| 5

     FOR EACH i IN {1, ..., 5} TASK 0 OUTPUTS i
     -| 1
     -| 2
     -| 3
     -| 4
     -| 5

     FOR EACH i IN {5, ..., 1} TASK 0 OUTPUTS i
     -| 5
     -| 4
     -| 3
     -| 2
     -| 1

     FOR EACH i IN {1, ..., 5}, {8, 7, 5, 4, 5} TASK 0 OUTPUTS i
     -| 1
     -| 2
     -| 3
     -| 4
     -| 5
     -| 8
     -| 7
     -| 5
     -| 4
     -| 5

     FOR EACH i IN {1, 4, 7, ..., 30} TASK 0 OUTPUTS i
     -| 1
     -| 4
     -| 7
     -| 10
     -| 13
     -| 16
     -| 19
     -| 22
     -| 25
     -| 28

     FOR EACH i IN {3**1, 3**2, 3**3, ..., 3**7} TASK 0 OUTPUTS i
     -| 3
     -| 9
     -| 27
     -| 81
     -| 243
     -| 729
     -| 2187

     FOR EACH i IN {0}, {1, 2, 4, ..., 256} TASK 0 OUTPUTS i
     -| 0
     -| 1
     -| 2
     -| 4
     -| 8
     -| 16
     -| 32
     -| 64
     -| 128
     -| 256

     FOR EACH i IN {neigh FOR EACH neigh IN {0,...,100} WHERE
     MESH_DISTANCE((10,10), 55, neigh) IS IN {1, 2}} TASK 0 OUTPUTS i.
     -| 35
     -| 44
     -| 45
     -| 46
     -| 53
     -| 54
     -| 56
     -| 57
     -| 64
     -| 65
     -| 66
     -| 75

   That final example loops over all values that are a Manhattan
distance of either 1 or 2 from the number 55 in a 10x10 layout of the
numbers 0-99.

   `FOR EACH' loops with constant progressions are executed exactly
once.  Note that if the <RANGE> does not contain an ellipsis then all
values are used, regardless of order or constancy:

     FOR EACH i IN {4, 4, 4, ..., 4} TASK 0 OUTPUTS i
     -| 4

     FOR EACH i IN {4, 4, 4, 4, 4} TASK 0 OUTPUTS i
     -| 4
     -| 4
     -| 4
     -| 4
     -| 4


File: conceptual.info,  Node: Timed loops,  Prev: Range loops,  Up: Iterating

Timed loops
...........

A "timed loop" is similar to a counted loop (*note Counted loops::) but
instead of running for a given number of iterations it runs for a given
length of time.  Timed loops are absent from all general-purpose
programming languages but can be quite useful in the context of network
correctness and performance testing.  The syntax of CONCEPTUAL's
timed-loop construct is "`FOR' <EXPR> <TIME_UNIT> <SIMPLE_STMT>".  <TIME_UNIT>
is unit of time as listed in *note Delaying execution:: and <EXPR>
specified the number of <TIME_UNIT>s for which to execute.

   The following example shows how to spend three seconds sending
messages from task 0 to task 1:

     FOR 3 SECONDS TASK 0 SENDS A 1 MEGABYTE MESSAGE TO TASK 1

   Although CONCEPTUAL tries its best to run for exactly the specified
length of time there will invariably be some error in the process.
Always use `elapsed_usecs' (*note Predeclared variables::) as the
indicator of actual time instead of the time requested in the loop.


File: conceptual.info,  Node: Binding variables,  Next: Conditional execution,  Prev: Iterating,  Up: Complex statements

4.7.3 Binding variables
-----------------------

There are four ways to bind a value to a variable:

  1. as part a source or target task description (*note Task
     descriptions::)

  2. as part of a range loop (*note Range loops::)

  3. via a command-line argument (*note Command-line arguments::)

  4. explicitly using the `LET' keyword (this section)

   The `LET' statement has the following form:

        `LET' <LET_BINDING>
        [`AND' <LET_BINDING>]*
        `WHILE' <SIMPLE_STMT>

where <LET_BINDING> is defined as follows:

<LET_BINDING>   ::=   <IDENT> `BE'       expr
                                     |   <SOURCE_TASK>
                                     |   `A RANDOM TASK' [<RANDOM_TASK_CONSTRAINTS>]

   The optional <RANDOM_TASK_CONSTRAINTS> limits the set of tasks from
which `A RANDOM TASK' selects:

<RANDOM_TASK_CONSTRAINTS>   ::=   `OTHER THAN' <EXPR>
                            |     `LESS THAN' <EXPR> [`BUT NOT' <EXPR>]
                            |     `GREATER THAN' <EXPR> [`BUT NOT' <EXPR>]
                            |     `IN' `[' <EXPR> `,' <EXPR> `]' [`BUT NOT' <EXPR>]

   An <IDENT> bound using the form ``LET' <IDENT> `BE' <SOURCE_TASK>'
represents a group of tasks and must therefore be accessed using the `TASK
GROUP' construct (*note Source tasks::).  For example, in the CONCEPTUAL
program

     LET left BE TASKS t SUCH THAT t < num_tasks/2 WHILE TASK GROUP left
     SENDS A 1 KILOBYTE MESSAGE TO TASK num_tasks - left - 1

the ``TASK GROUP' left' expression defines `left' as the group of tasks
described by ``TASKS' t `SUCH THAT' t < num_tasks/2'.  The `left' in
`num_tasks - left - 1' refers back to _that_ definition of `left', not
the let-bound `left'.  The `t' in the let-binding is used only to
specify the group of tasks that will be bound to `left'.  Its scope is
limited to the expression `t < num_tasks/2'.  In other words, the
preceding example is equivalent to

     TASKS left SUCH THAT left < num_tasks/2 SEND A 1 KILOBYTE MESSAGE TO
     TASK num_tasks - left - 1

   The advantage of using `LET' to define a task group is that the
same--possible complex--description of a set of tasks can be reused in
multiple statements without having to type it repeatedly.

   Here are some further examples of `LET':

     LET reps BE 3 WHILE FOR reps REPETITIONS TASK 0 OUTPUTS "Laissez les
     bons temps rouler."

     LET src BE num_tasks-1 AND dest BE num_tasks/2 WHILE TASK src SENDS A
     55E6 BIT MESSAGE TO TASK dst

     LET hotspot BE A RANDOM TASK WHILE TASKS other SUCH THAT
     other<>hotspot SEND 1000 1 MEGABYTE MESSAGES TO TASK hotspot

     LET target BE A RANDOM TASK OTHER THAN 3 WHILE TASK 3 SENDS A 24 BYTE
     MESSAGE TO TASK target

     LET x BE A RANDOM TASK AND y be a RANDOM TASK GREATER THAN x WHILE
     TASK 0 OUTPUTS "Did you know that " AND x AND " is less than " AND y
     AND "?"

     LET nonzero BE A RANDOM TASK LESS THAN 10 BUT NOT 0 WHILE TASK nonzero
     SLEEPS FOR 2 SECONDS

     LET middles BE A RANDOM TASK IN [1, num_tasks-2] WHILE TASK middles
     ASYNCHRONOUSLY SENDS A 10 BYTE MESSAGE TO TASK ends SUCH THAT ends IS
     NOT IN [1, num_tasks-2]

     LET num BE 1000 AND num BE num*2 WHILE TASK 0 OUTPUTS num
     -| 2000

   That last example demonstrates that `LET' can bind a variable to a
function of its previous value.  It is important to remember, though,
that variables in CONCEPTUAL cannot be assigned, only bound to a value
for the duration of the current scope.  They can, however, be bound to
a different value for the duration of a child scope.  The following
example is an attempt to clarify the distinction between binding and
assignment:

     LET var BE 123 WHILE FOR 5 REPETITIONS LET var BE var+1 WHILE TASK 0
     OUTPUTS var
     -| 124
     -| 124
     -| 124
     -| 124
     -| 124

In that example, `var' is bound to `123' for the scope containing the `FOR'
statement.  Then, within the `FOR' statement, a new scope begins with
`var' being given one plus the value it had in the outer scope,
resulting in `124'.  If CONCEPTUAL supported assignment instead of
variable-binding, the program would have output `124', `125', `126',
`127', and `128'.  Note that if `A RANDOM TASK' were used in the
example instead of `var+1', `var' would get a different value in each
iteration.

   When a variable is `LET'-bound to `A RANDOM TASK', all tasks agree
on the random number.  Otherwise, task A might send a message to task B
but task B might be expecting to receive the message from task C,
thereby leading to a variety of problems.  If there are no valid random
tasks, as in the following example, `A RANDOM TASK' will return `-1':

     LET invalid_task BE A RANDOM TASK GREATER THAN num_tasks WHILE TASK 0
     OUTPUTS invalid_task
     -| -1

Furthermore, the <EXPR> passed to `GREATER THAN' is bounded from below
by `0' and the <EXPR> passed to `LESS THAN' is bounded from above by
`num_tasks-1'.  Hence, the following CONCEPTUAL statement will always
output values less than or equal to `num_tasks-1' (unless `num_tasks'
is greater than 1*10^6, of course, in which case it will always output
values less than 1*10^6):

     LET valid_task BE A RANDOM TASK LESS THAN 1E6 WHILE TASK valid_task
     OUTPUTS "Hello from " AND valid_task


File: conceptual.info,  Node: Conditional execution,  Next: Grouping,  Prev: Binding variables,  Up: Complex statements

4.7.4 Conditional execution
---------------------------

Like most programming languages, CONCEPTUAL supports conditional code
execution:

<IF_STMT>   ::=   `IF' <REL_EXPR>
                  `THEN' <SIMPLE_STMT>
                  [`OTHERWISE' <SIMPLE_STMT>]

   The semantics of an <IF_STMT> are that if <REL_EXPR> (*note
Relational expressions::) is TRUE then the first <SIMPLE_STMT> is
executed.  If <REL_EXPR> is FALSE then the second <SIMPLE_STMT> is
executed.  One restriction is that <REL_EXPR> must return the same truth
value to every task.  Consequently, functions that involve
task-specific random numbers (*note Random-number functions::) are
forbidden within <REL_EXPR>.

   The following is an example of an <IF_STMT>:

     IF this>that THEN TASK 0 SENDS A 3 KILOBYTE MESSAGE TO TASK this
     OTHERWISE TASK num_tasks-1 SENDS A 4 KILOBYTE MESSAGE TO TASK that


File: conceptual.info,  Node: Grouping,  Prev: Conditional execution,  Up: Complex statements

4.7.5 Grouping
--------------

`FOR' loops, `LET' bindings, and `IF' statements operate on a single <SIMPLE_STMT>
(or two <SIMPLE_STMT>s in the case of `IF'...`OTHERWISE').  Operating
on multiple <SIMPLE_STMT>s--or, more precisely, operating on a single <COMPLEX_STMT>
that may consist of multiple <SIMPLE_STMT>s--is a simple matter of
placing the <SIMPLE_STMT>s within curly braces.  Contrast the following:

     FOR 3 REPETITIONS TASK 0 OUTPUTS "She loves me." THEN TASK 0 OUTPUTS
     "She loves me not."
     -| She loves me.
     -| She loves me.
     -| She loves me.
     -| She loves me not.

     FOR 3 REPETITIONS {TASK 0 OUTPUTS "She loves me." THEN TASK 0 OUTPUTS
     "She loves me not."}
     -| She loves me.
     -| She loves me not.
     -| She loves me.
     -| She loves me not.
     -| She loves me.
     -| She loves me not.

In other words, everything between `{' and `}' is treated as if it were
a single statement.  Hence, the `FOR' loop applies only to the "She
loves me" output in the first statement above, while the `FOR' loop
applies to both "She loves me" and "She loves me not" in the second
statement.

   Variable scoping is limited to the <SIMPLE_STMT> in the body of a `LET':

     LET year BE 1984 WHILE LET year BE 2084 WHILE TASK 0 OUTPUTS year THEN
     TASK 0 OUTPUTS year
     error--> The second `year' is outside the scope of both `LET' statements.

     LET year BE 1984 WHILE {{LET year BE 2084 WHILE TASK 0 OUTPUTS year}
     THEN TASK 0 OUTPUTS year}
     -| 2084
     -| 1984

   As indicated by the grammatical rules presented at the beginning of
*note Complex statements::, CONCEPTUAL does support empty pairs of curly
braces, which represent a statement that does nothing and takes no time
to execute.  While never strictly needed, `{}' may be a convenient
mechanism for mechanically produced CONCEPTUAL programs.


File: conceptual.info,  Node: Other statements,  Next: Header declarations,  Prev: Complex statements,  Up: Grammar

4.8 Other statements
====================

CONCEPTUAL contains a few more statements than those described in *note
Communication statements:: and *note I/O statements::.  As there is no
category that clearly describes the remaining statements, they are
listed here in this "catch-all" section.

* Menu:

* Asserting conditions::        Aborting if a program requirement is not met
* Delaying execution::          Introducing artificial delays into a program
* Touching memory::             Occupying the CPU or the memory hierarchy
* Reordering task IDs::         Changing the virtual->physical task map
* Injecting arbitrary code::    Executing backend-specific code verbatim


File: conceptual.info,  Node: Asserting conditions,  Next: Delaying execution,  Prev: Other statements,  Up: Other statements

4.8.1 Asserting conditions
--------------------------

CONCEPTUAL programs can encode the run-time conditions that must hold in
order for the test to run properly.  This is achieved through
"assertions", which are expressed as follows:

<ASSERT_STMT>   ::=   `ASSERT THAT' <STRING>
                      `WITH' <REL_EXPR>

   <STRING> is a message to be reported to the user if the assertion
fails.  <REL_EXPR> is a relational expression (as described in *note
Relational expressions::) that must evaluate to TRUE for the program to
continue running.  Assertion failures are considered fatal errors.
They cause the CONCEPTUAL program to abort immediately.

   Here are some sample <ASSERT_STMT>s:

     ASSERT THAT "the bandwidth test requires at least two tasks" WITH
     num_tasks >= 2

     ASSERT THAT "pairwise ping-pongs require an even number of task"
     WITH num_tasks IS EVEN

     ASSERT THAT "this program requires a square number of tasks" WITH
     SQRT(num_tasks)**2 = num_tasks

(For the last example, recall that CONCEPTUAL expressions are of integer
type.  Hence, the example's <REL_EXPR> is mathematically equivalent to
floor(sqrt(N))^2 = N, which is TRUE if and only if N is a square.)


File: conceptual.info,  Node: Delaying execution,  Next: Touching memory,  Prev: Asserting conditions,  Up: Other statements

4.8.2 Delaying execution
------------------------

It is sometimes interesting to measure the progress of a communication
pattern when delays are inserted at various times on various tasks.
CONCEPTUAL provides two mechanisms for inserting delays: one that
relinquishes the CPU while delaying (`SLEEP') and one that hoards it (`COMPUTE').

<DELAY_STMT>   ::=   <SOURCE_TASK>
                     `SLEEPS' | `COMPUTES'
                     `FOR' <EXPR> <TIME_UNIT>

   <SOURCE_TASK> (*note Source tasks::) specifies the set of tasks that
will stall.  <EXPR> (*note Arithmetic expressions::) specifies the
number of <TIME_UNIT>s for which to delay and <TIME_UNIT> represents
any of the following measures of time:

<TIME_UNIT>   ::=   `MICROSECONDS' | `MILLISECONDS' | `SECONDS' |      `MINUTES' | `HOURS' |
                    `DAYS'

   Delay times are only approximate.  `SLEEP''s accuracy depends upon
the operating-system's clock resolution or length of time quantum
(commonly measured in milliseconds or tens of milliseconds).  `COMPUTE',
which is implemented by repeatedly reading a variable until the desired
amount of time elapses, is calibrated during the CONCEPTUAL run-time
system's initialization phase and can be adversely affected by
intermittant system load.  Both forms of <DELAY_STMT> attempt to
measure wall-clock time ("real time"), not just the time the program is
running ("virtual time").  Because the delay times are approximate, it
is strongly recommended that the `elapsed_usecs' variable (*note
Predeclared variables::) be employed to determine the actual elapsed
time.


File: conceptual.info,  Node: Touching memory,  Next: Reordering task IDs,  Prev: Delaying execution,  Up: Other statements

4.8.3 Touching memory
---------------------

"Touching" memory means reading and writing it.  The CONCEPTUAL `TOUCHES'
statement enables a program to touch memory for one of two purposes:
either to simulate computation in an application by thrashing some or
all of the memory hierarchy or to preload message buffers into the
upper levels of the memory hierarchy in order to better separate
communication costs from memory costs.

* Menu:

* Simulating computation::      Touching memory to mimic computation
* Priming message buffers::     Touching memory to warm up message buffers


File: conceptual.info,  Node: Simulating computation,  Next: Priming message buffers,  Prev: Touching memory,  Up: Touching memory

Simulating computation
......................

While the statements described in *note Delaying execution:: delay for a
specified length of time, it is also possible to delay for the duration
of a specified amount of "work".  "Work" is expressed in terms of
memory accesses.  That is, a CONCEPTUAL program can touch (i.e., read
plus write) data with a given stride from a memory region of a given
size.  By varying these parameters, a program can emulate an
application's computation by hoarding the CPU or any level of the
memory hierarchy.

<TOUCH_STMT>   ::=   <SOURCE_TASK>
                     `TOUCHES'
                     [<EXPR> <DATA_TYPE> `OF']
                     `AN' <ITEM_SIZE> `MEMORY REGION'
                     [<EXPR> `TIMES']
                     [`WITH STRIDE' <EXPR> <DATA_TYPE> | `WITH RANDOM STRIDE']

<ITEM_SIZE> and <DATA_TYPE> are described in *note Item size:: and <EXPR>
is described in *note Arithmetic expressions::.

   As shown by the formal definition of <TOUCH_STMT> the required
components are a <SOURCE_TASK> and the size of the memory region to
touch.  By default, every `WORD' (*note Item size::) of memory in the
region is touched exactly once.  The type of data that is touched can
be varied with an `<EXPR> <DATA_TYPE> OF' clause.  For instance, `100
BYTES OF' of a memory region will touch individual bytes.  An optional
repeat count enables the memory region (or subset thereof) to be
touched multiple times.  Hence, if `TASK 0 TOUCHES A 6 MEGABYTE MEMORY
REGION 5 TIMES', then the touch will be performed as if `TASK 0' were
told to `TOUCH 5*6M BYTES OF A 6 MEGABYTE MEMORY REGION 1 TIME' or
simply to `TOUCH 5*6M BYTES OF A 6 MEGABYTE MEMORY REGION'.

   By default, every <DATA_TYPE> of data is touched.  However, a <TOUCH_STMT>
provides for touching only a subset of the <DATA_TYPE>s in the memory
region.  By writing `WITH STRIDE <EXPR> <DATA_TYPE>', only the first <DATA_TYPE>
out of every <EXPR> will be touched.  Instead of specifying an exact
stride, the memory region can be accessed in random order using the `WITH
RANDOM STRIDE' clause.

   Unless the number of touches and data type are specified explicitly,
the number of `WORD's that are touched is equal to the size of the
memory region divided by the stride length then multiplied by the
repeat count.  Therefore, if `TASK 0 TOUCHES AN 8 MEGABYTE MEMORY
REGION 2 TIMES WITH STRIDE 8 WORDS', then a total of (2^23 / (4*8)) * 2
= 524288 touches will be performed.  For the purpose of the preceding
calculation, `WITH RANDOM STRIDE' should be treated as if it were `WITH
STRIDE 1 WORD' (again, unless the number of touches and data type are
specified explicitly).

   To save memory, all `TOUCH' statements in a CONCEPTUAL program
access subsets of the same region of memory, whose size is determined
by the maximum needed.  However, each dynamic execution of a <TOUCH_STMT>
starts touching from where the previous execution left off.  For
example, consider the following statement:

     TASK 0 TOUCHES 100 WORDS OF A 200 WORD MEMORY REGION

The first time that that statement is executed within a loop (*note
Iterating::), the first 200 words are touched.  The second time, the
second 200 words are touched.  The third time, the index into the
region wraps around and the first 200 words are touched again.

   Each static <TOUCH_STMT> maintains its own index into the memory
region.  Therefore, the first of the following two statements will
terminate successfully (assuming it's not executed in the body of a
loop) while the second will result in a run-time error because the
final byte of the final word does not fit within the given memory
region.

     TASK 0 TOUCHES 100 WORDS OF A 799 BYTE MEMORY REGION THEN
     TASK 0 TOUCHES 100 WORDS OF A 799 BYTE MEMORY REGION

     FOR 2 REPETITIONS TASK 0 TOUCHES 100 WORDS OF A 799 BYTE MEMORY REGION

(`THEN' is described in *note Combining statements::, and `FOR'...`REPETITIONS'
is described in *note Counted loops::.)  The first statement shown
above touches the same 100 words (400 bytes) in each of the two <TOUCH_STMT>s.
The second statement touches the first 100 words the first time the <TOUCH_STMT>
is executed and fails when trying to touch the (only partially extant)
second 100 words.


File: conceptual.info,  Node: Priming message buffers,  Prev: Simulating computation,  Up: Touching memory

Priming message buffers
.......................

*note Data touching::, describes how a message sent or received `WITH
DATA TOUCHING' will have all of its data touched before or after
transmission.  Sometimes, however, a program may want to touch message
data without actually transmitting a message.  For example, a task
could touch message data to load it into the cache, then `RESET ITS
COUNTERS' (*note Resetting counters::), and finally send or receive a
message without further data touching.  The `TOUCHES' statement has an
alternate form that touches message buffers instead of isolated memory
regions:

<TOUCH_BUFFER_STMT>   ::=   <SOURCE_TASK>
                            `TOUCHES'
                            `ALL MESSAGE BUFFERS'
                            | `MESSAGE BUFFER' <EXPR>
                            | `THE CURRENT MESSAGE BUFFER'

   The first form, `ALL MESSAGE BUFFERS', touches all message buffers
available to the program, even those not yet used at the time `TOUCHES'
is invoked.  In the following statement, for example, `TOUCHES' "knows"
that 10 message buffers will be used and touches the data in all 10 of
them:

     ALL TASKS TOUCH ALL MESSAGE BUFFERS THEN
     FOR EACH SZ IN {0, ..., 9}
       TASK 0 ASYNCHRONOUSLY SENDS AN SZ MEGABYTE MESSAGE TO TASK 1 THEN
     ALL TASKS AWAIT COMPLETION

(*note Buffer control::, explains why the preceding statement requires
10 buffers.)  One caveat is that in CONCEPTUAL version 1.4, messages
sent or received with the `UNIQUE' keyword (*note Unique messages::)
are not touched.  This limitation may be lifted in a later release of
CONCEPTUAL.

   The second form of the <TOUCH_BUFFER_STMT> statement, `MESSAGE
BUFFER <EXPR>', touches a specific message buffer.  It is expected to
be used in programs that send `FROM BUFFER <EXPR>' or receive `INTO
BUFFER <EXPR>'.

   `THE CURRENT MESSAGE BUFFER', the third and final form of the <TOUCH_BUFFER_STMT>
statement, touches the first message buffer that is not currently in
use (i.e., is not the source or destination of an asynchronous
operation).  Usually, this is whichever message buffer will next be
sent from or received into.  (The exception is when a task `AWAITS
COMPLETION' after touching the current message buffer but before
sending or receiving a message--probably a somewhat contrived
situation.)


File: conceptual.info,  Node: Reordering task IDs,  Next: Injecting arbitrary code,  Prev: Touching memory,  Up: Other statements

4.8.4 Reordering task IDs
-------------------------

CONCEPTUAL distinguishes between "task IDs", which are used in task
descriptions (*note Task descriptions::) and "processor IDs", which are
assigned by the underlying communication layer.  As stated in *note
Running coNCePTuaL programs::, a CONCEPTUAL program has no control over
how processor IDs map to physical processors.  It therefore has no way
to specify, for instance, that a set of tasks must run on the same
multiprocessor node (or on different nodes, for that matter).
Initially, every task's task ID is set equal to its processor ID.
However, while processor IDs are immutable, task IDs can be changed
dynamically during the execution of a program.  Altering task IDs can
simplify CONCEPTUAL programs that might otherwise need to evaluate
complex expressions to determine peer tasks.  CONCEPTUAL enables either
a specific or a randomly selected task to be assigned to a given
processor:

<PROCESSOR_STMT>   ::=   <SOURCE_TASK>
                         `IS ASSIGNED TO'
                         `PROCESSOR' <EXPR> | `A RANDOM PROCESSOR'

   In addition to performing the specified processor assignment,
CONCEPTUAL will perform an additional, implicit processor assignment in
order to maintain a bijection between task IDs and processor IDs (i.e.,
every task ID corresponds to exactly one processor ID and every
processor ID corresponds to exactly one task ID).  Consider the
following statement:

     TASK n SUCH THAT n<(num_tasks+1)/2 IS ASSIGNED TO PROCESSOR n*2

If `num_tasks' is `8' the preceding statement will cause `TASK 0' to
refer to processor 0, `TASK 1' to refer to processor processor 2,
`TASK 2' to refer to processor 4, and `TASK 3' to refer to processor 6.
What may be unintuitive is that the remaining tasks will not map to
their original processors, as doing so would violate the bijection
invariant.  To clarify CONCEPTUAL's implicit processor assignments the
following timeline illustrates the execution of `TASK n SUCH THAT
n<(num_tasks+1)/2 IS ASSIGNED TO PROCESSOR n*2' when `num_tasks' is `8':

`n'   `TASK 0'   `TASK 1'   `TASK 2'   `TASK 3'   `TASK 4'   `TASK 5'   `TASK 6'   `TASK 7'
--    0          1          2          3          4          5          6          7
0     0          1          2          3          4          5          6          7
1     0          *2*        *1*        3          4          5          6          7
2     0          2          *4*        3          *1*        5          6          7
3     0          2          4          *6*        1          5          *3*        7

   Initially, task and processor IDs are equal.  When `n' takes on the
value 0, CONCEPTUAL performs the equivalent of `TASK 0 IS ASSIGNED TO
PROCESSOR 0', which does not change the task ID to processor ID
mapping.  When `n' is 1, CONCEPTUAL performs the equivalent of `TASK 1
IS ASSIGNED TO PROCESSOR 2', which sets task 1's processor to 2.
However, because task 2 also has processor 2, CONCEPTUAL implicitly
performs the equivalent of `TASK 2 IS ASSIGNED TO PROCESSOR 1' in order
to preserve the unique task ID to processor ID mapping.  When `n' is 2,
CONCEPTUAL performs the equivalent of `TASK 2 IS ASSIGNED TO PROCESSOR
4' and, because task 4 also has processor 4, the equivalent of `TASK 4
IS ASSIGNED TO PROCESSOR 1'.  Finally, when `n' is 3, CONCEPTUAL
performs the equivalent of `TASK 3 IS ASSIGNED TO PROCESSOR 6' and,
because task 6 also has processor 6, the equivalent of `TASK 6 IS
ASSIGNED TO PROCESSOR 3'.  Thus, CONCEPTUAL maintains the invariant
that after any processor assignment every task corresponds to a unique
processor and every processor corresponds to a unique task.


File: conceptual.info,  Node: Injecting arbitrary code,  Prev: Reordering task IDs,  Up: Other statements

4.8.5 Injecting arbitrary code
------------------------------

There are some features that are outside the scope of the CONCEPTUAL
language.  However, CONCEPTUAL provides a mechanism for inserting
backend-specific statements into the control flow of a CONCEPTUAL
program.  This feature is intended for users with specific needs that
can't be satisfied through the conventional CONCEPTUAL statements.

<BACKEND_STMT>   ::=   <SOURCE_TASK>
                       `BACKEND EXECUTES'
                       <EXPR> | <STRING>
                       [`AND' <EXPR> | <STRING>]*

   The following example assumes a C-based backend:

     ALL TASKS taskID BACKEND EXECUTE "my_c_function(" AND taskID AND ");"

The `my_c_function()' function needs be defined in some object file and
linked with the CONCEPTUAL-generated code.

   Most users will never need to `BACKEND EXECUTE' code.  In fact, most
users should _not_ use <BACKEND_STMT>s as they produce nonportable
code.  One of CONCEPTUAL's goals is for programs to be understandable
by people unfamiliar with the language, and <BACKEND_STMT>s thwart that
goal.  However, <BACKEND_STMT>s do help ensure that all of the target
language/library's features are available to CONCEPTUAL.

   All <EXPR>s are passed to the backend in floating-point context
(*note Evaluation contexts::).  Consequently, all backend code that
takes a CONCEPTUAL <EXPR> needs to expect a floating-point value (which
the backend code can of course cast explicitly to an integer if
necessary).

   There is an important special case defined for the argument to the `BACKEND
EXECUTES' statement: once all of the <STRING> and <EXPR> arguments are
concatenated into a single string, all occurrences of the substring
`[MESSAGE BUFFER EXPR]' are replaced by a pointer to the EXPRth message
buffer created using the `FROM BUFFER' or `INTO BUFFER' keywords
(presented in *note Buffer control::).  This special case makes it easy
for a CONCEPTUAL program to invoke communication functions provided by
the underlying communications library.  Note that the notion of a
default buffer is not meaningful in the context of `BACKEND EXECUTES',
which is not a communication statement.

   *Note Backend-specific declarations::, for a description of `BACKEND
DECLARES', a companion statement to EXECUTES `BACKEND EXECUTES' that
enables CONCEPTUAL programs to directly declare variables and functions
in the target language.


File: conceptual.info,  Node: Header declarations,  Next: Complete programs,  Prev: Other statements,  Up: Grammar

4.9 Header declarations
=======================

CONCEPTUAL programs may contain a header section that precedes the first
statement in a CONCEPTUAL program.  The header section contains three
types of declarations that affect the remainder of the program:
language versioning declarations, declarations of command-line options,
and backend-specific variable and function declarations.

* Menu:

* Language versioning::         Preventing errors caused by language changes
* Command-line arguments::      Setting variables from command-line arguments
* Backend-specific declarations::  Declaring variables and functions verbatim


File: conceptual.info,  Node: Language versioning,  Next: Command-line arguments,  Prev: Header declarations,  Up: Header declarations

4.9.1 Language versioning
-------------------------

Because the CONCEPTUAL language is still under development, the
programmer is forewarned that major changes are likely.  Changes may
prevent old code from compiling or, even worse, may cause old code to
produce incorrect results (e.g., if scoping or block structuring are
altered).  To mitigate future language changes CONCEPTUAL enables
programs to specify which version of the language they were written to.
The syntax is straightforward:

<VERSION_DECL>   ::=   `REQUIRE LANGUAGE VERSION' <STRING>

   The parser issues a warning message if <STRING> does not exactly
match the language version supported by the compiler.  If the program
successfully compiles after a version-mismatch warning, the programmer
should check the output very carefully to ensure that the program
behaved as expected.

   The current version of the CONCEPTUAL language is `1.4'.  Note that
the language version does not necessarily correspond to the version of
the CONCEPTUAL toolset (*note Usage::) as a whole.


File: conceptual.info,  Node: Command-line arguments,  Next: Backend-specific declarations,  Prev: Language versioning,  Up: Header declarations

4.9.2 Command-line arguments
----------------------------

CONCEPTUAL makes it easy to declare command-line parameters, although
the syntax is a bit verbose:

<PARAM_DECL>   ::=   <IDENT>
                     `IS' <STRING>
                     `AND COMES FROM' <STRING> `OR' <STRING>
                     `WITH DEFAULT' <EXPR>

   <IDENT> is the CONCEPTUAL variable being declared.  The first <STRING>
is a descriptive string that is provided when the user runs the program
with `--help' or `-?'.  The `<STRING> OR <STRING>' terms list the long
name for the command-line option, preceded by `--', and the short
(single-character) name, preceded by `-'.  Finally, <EXPR> specifies
the value that will be assigned to <IDENT> if the command-line option
is not used.  <EXPR> must be a constant expression and may not utilize
any of the random-number functions listed in *note Random-number
functions::.  Note that short names (also long names) must be unique.

   For instance, the declaration `nummsgs IS "Number of messages to
send" AND COMES FROM "--messages" OR "-m" WITH DEFAULT 25*4' declares a
new CONCEPTUAL variable called `nummsgs'.  `nummsgs' is given the value
`100' (`25*4') by default.  However, if the user running the program
specifies, for example, `--messages=55' (or, equivalently, `-m 55'),
then `nummsgs' will be given the value `55'.  The following is an
example of the output that might be produced if the program is run with `--help'
or `-?':

     Usage: a.out [OPTION...]
       -m, --messages=<number>     Number of messages to send [default: 100]
       -C, --comment=<string>      Additional commentary to write to the log
                                   file, @FILE to import commentary from FILE,
                                   or !COMMAND to import commentary from COMMAND
                                   (may be specified repeatedly)
       -L, --logfile=<string>      Log-file template [default: "a.out-%p.log"]
       -N, --no-trap=<string>      List of signals that should not be trapped
                                   [default: ""]

     Help options:
       -?, --help                  Show this help message
       --usage                     Display brief usage message

   The above is only an example.  Depending on what libraries were
available when the CONCEPTUAL run-time system was configured, the output
could be somewhat different.  Also, long options may not be supported
if a suitable argument-processing library was not available at
configuration time.  The above example does indicate one way that help
strings could be formatted.  It also shows that the CONCEPTUAL run-time
system reserves some command-line options for its own purposes.
Currently, these all use uppercase letters for their short forms so it
should be safe for programs to use any lowercase letter.


File: conceptual.info,  Node: Backend-specific declarations,  Prev: Command-line arguments,  Up: Header declarations

4.9.3 Backend-specific declarations
-----------------------------------

The `BACKEND EXECUTES' statement (*note Injecting arbitrary code::)
provides support for executing non-CONCEPTUAL code from a CONCEPTUAL
program.  A related construct, `BACKEND DECLARES', provides support for
embedding non-CONCEPTUAL variable and function declarations in a
CONCEPTUAL program:

<BACKEND_DECL>   ::=   `THE BACKEND DECLARES' <STRING>

   Like `BACKEND EXECUTES', `BACKEND DECLARES' produces nonportable
code.  Its use is therefore strongly discouraged.  However, `BACKEND
DECLARES' and `BACKEND EXECUTES' together help ensure that all of the
target language/library's features are available to CONCEPTUAL.

   The following example uses `BACKEND DECLARES' to declare a C global
variable and two C functions that access that variable:

     THE BACKEND DECLARES "
     int tally = 0;

     void increment_tally (void)
     {
       tally++;
     }

     void show_tally (char *msg)
     {
       printf(\"%s%d.\\n\", msg, tally);
     }
     ".

     FOR 3 REPETITIONS PLUS 2 WARMUP REPETITIONS {
       ALL TASKS src SEND A 512-BYTE MESSAGE TO TASK src+1 THEN
       ALL TASKS BACKEND EXECUTE "increment_tally();"
     } THEN
     TASK 0 BACKEND EXECUTES "show_tally(\"Tally is\\n==> \");".

The preceding code works only when using a C-based backend such as `c_mpi'
or `c_udgram'.  Eliciting the same behavior from a Python-based backend
such as `interpret' or `latex_vis' requires a complete rewrite of the
CONCEPTUAL code:

     THE BACKEND DECLARES "
     global tally
     tally = 0

     def increment_tally():
         global tally
         tally = tally + 1

     def show_tally(msg):
         global tally
         print \"%s%d.\\n\" % (msg, tally)
     "

     FOR 3 REPETITIONS PLUS 2 WARMUP REPETITIONS {
       ALL TASKS src SEND A 512-BYTE MESSAGE TO TASK src+1 THEN
       ALL TASKS BACKEND EXECUTE "increment_tally()"
     } THEN
     TASK 0 BACKEND EXECUTES "show_tally(\"Tally is\\n==> \")".

It is because of this need to rewrite programs for each set of backends
that `BACKEND DECLARES' and `BACKEND EXECUTES' should be used only when
absolutely necessary.


File: conceptual.info,  Node: Complete programs,  Next: Summary of the grammar,  Prev: Header declarations,  Up: Grammar

4.10 Complete programs
======================

A complete CONCEPTUAL program consists of zero or more header
declarations (*note Header declarations::), each terminated with a `.',
followed by one or more complex statements (*note Complex
statements::), each also terminated with a `.'.  More formally,
CONCEPTUAL's top-level nonterminal is the <PROGRAM>:

<PROGRAM>   ::=   (<VERSION_DECL> | <PARAM_DECL> | <BACKEND_DECL> [`.'])*
                  (<TOP_LEVEL_COMPLEX_STMT> [`.'])+

<TOP_LEVEL_COMPLEX_STMT>   ::=   <COMPLEX_STMT>

   Because a <COMPLEX_STMT> can reduce to a <SIMPLE_STMT>, the most
basic, complete CONCEPTUAL program would be a <SIMPLE_STMT> with a
terminating period:

     ALL TASKS self OUTPUT "Hello from task " AND self AND "!".

A fuller example might contain multiple header declarations and
multiple <COMPLEX_STMT>s:

     # A complete coNCePTuaL program
     # By Scott Pakin <pakin@lanl.gov>

     REQUIRE LANGUAGE VERSION "1.4".

     maxval IS "Maximum value to loop to" AND COMES FROM "--maxval" OR
       "-v" WITH DEFAULT 100.

     step IS "Increment after each iteration" AND COMES FROM "--step" OR
       "-s" WITH DEFAULT 1.

     TASK 0 OUTPUTS "Looping from 0 to " AND maxval AND " by " AND step
       AND "...".

     FOR EACH loopvar IN {0, step, ..., maxval}
       TASK 0 OUTPUTS "    " AND loopvar.

     TASK 0 OUTPUTS "Wasn't that fun?".

   Technically, the `.' is optional; the language is unambiguous
without it.  However, for aesthetic purposes it is recommended that you
terminate sentences with a period, just like in a natural language.  An
exception would be when a <COMPLEX_STMT> ends with a curly brace.  The
`}.' syntax is unappealing so a simple `}' should be used instead.
*Note Examples::, for further examples.

* Menu:

* Top-level statements and log files::  One statement = one table in the log


File: conceptual.info,  Node: Top-level statements and log files,  Prev: Complete programs,  Up: Complete programs

Top-level statements and log files
----------------------------------

The reason that CONCEPTUAL distinguishes between <TOP_LEVEL_COMPLEX_STMT>s
and <COMPLEX_STMT>s is that <TOP_LEVEL_COMPLEX_STMT>s begin a new table
in the log file (*note Writing to a log file::) while <COMPLEX_STMT>s
add columns to the current table.  Consider the following piece of code:

     TASK 0 LOGS 111 AS "First" AND
                 222 AS "Second".

   Because `First' and `Second' are logged within the same <SIMPLE_STMT>
they appear in the log file within the same table but as separate
columns:

     "First","Second"
     "(all data)","(all data)"
     111,222

   The same rule holds when `LOGS' is used repeatedly across <SIMPLE_STMT>s
but within the same <COMPLEX_STMT>:

     TASK 0 LOGS 111 AS "First" THEN
     TASK 0 LOGS 222 AS "Second".

   However, if `First' and `Second' are logged from separate <TOP_LEVEL_COMPLEX_STMT>s,
the CONCEPTUAL run-time library stores them in separate tables:

     TASK 0 LOGS 111 AS "First".
     TASK 0 LOGS 222 AS "Second".

     "First"
     "(all data)"
     111

     "Second"
     "(all data)"
     222


File: conceptual.info,  Node: Summary of the grammar,  Prev: Complete programs,  Up: Grammar

4.11 Summary of the grammar
===========================

The following is the complete grammar for the CONCEPTUAL language.  The
EBNF productions appear here in the order that they were presented in
the rest of the chapter.

<EXPR>   ::=   <COND_EXPR>

<COND_EXPR>   ::=   <ADD_EXPR> `IF' <REL_EXPR> `OTHERWISE' <ADD_EXPR>

<ADD_EXPR>   ::=   <MULT_EXPR>
             |     <ADD_EXPR> `+' <MULT_EXPR>
             |     <ADD_EXPR> `-' <MULT_EXPR>
             |     <ADD_EXPR> `|' <MULT_EXPR>
             |     <ADD_EXPR> `XOR' <MULT_EXPR>

<MULT_EXPR>   ::=   <UNARY_EXPR>
              |     <MULT_EXPR> `*' <UNARY_EXPR>
              |     <MULT_EXPR> `/' <UNARY_EXPR>
              |     <MULT_EXPR> `MOD' <UNARY_EXPR>
              |     <MULT_EXPR> `>>' <UNARY_EXPR>
              |     <MULT_EXPR> `<<' <UNARY_EXPR>
              |     <MULT_EXPR> `&' <UNARY_EXPR>

<POWER_EXPR>   ::=   <PRIMARY_EXPR> [`**' <UNARY_EXPR>]

<UNARY_EXPR>   ::=   <POWER_EXPR>
               |     <UNARY_OPERATOR> <UNARY_EXPR>

<UNARY_OPERATOR>   ::=   `+' | `-' | `NOT'

<PRIMARY_EXPR>   ::=   `(' <EXPR> `)'
                 |     <IDENT>
                 |     <INTEGER>
                 |     <FUNC_NAME> `(' <ENUMERATED_EXPRS> `)'
                 |     `REAL' `(' <EXPR> `)'

<ENUMERATED_EXPRS>   ::=   <EXPR> [`,' <EXPR>]*

<FUNC_NAME>   ::=   `ABS' | `BITS' | `CBRT' | `FACTOR10' | `LOG10' |      `MAX' | `MIN' | `ROOT' |
                    `SQRT'
              |     `CEILING' | `FLOOR' | `ROUND'
              |     `TREE_PARENT' | `TREE_CHILD'
              |     `KNOMIAL_PARENT' | `KNOMIAL_CHILD' | `KNOMIAL_CHILDREN'
              |     `MESH_NEIGHBOR' | `MESH_COORDINATE' | `MESH_DISTANCE'
              |     `RANDOM_UNIFORM' | `RANDOM_GAUSSIAN'
              |     `RANDOM_POISSON' | `RANDOM_PARETO'

<AGGR_EXPR>   ::=   [`EACH'] <EXPR>
              |     `THE' <EXPR>
              |     `THE' <AGGR_FUNC> [`OF' [`THE']] <EXPR>
              |     `A HISTOGRAM OF' [`THE'] <EXPR>

<AGGR_FUNC>   ::=   [`ARITHMETIC'] `MEAN' | `HARMONIC MEAN' | `GEOMETRIC MEAN' |
                    `MEDIAN' | `STANDARD DEVIATION' | `VARIANCE' |      `MEDIAN ABSOLUTE
                    DEVIATION' | `SUM' | `MINIMUM' |      `MAXIMUM' | `FINAL'

<REL_EXPR>   ::=   <REL_DISJ_EXPR>

<REL_DISJ_EXPR>   ::=   [<REL_DISJ_EXPR> `\/'] <REL_CONJ_EXPR>

<REL_CONJ_EXPR>   ::=   [<REL_CONJ_EXPR> `/\'] <REL_PRIMARY_EXPR>

<REL_PRIMARY_EXPR>   ::=   <EQ_EXPR>
                     |     `(' <REL_EXPR> `)'

<EQ_EXPR>   ::=   <EXPR> `=' <EXPR>
            |     <EXPR> `<' <EXPR>
            |     <EXPR> `>' <EXPR>
            |     <EXPR> `<=' <EXPR>
            |     <EXPR> `>=' <EXPR>
            |     <EXPR> `<>' <EXPR>
            |     <EXPR> `DIVIDES' <EXPR>
            |     <EXPR> `IS EVEN'
            |     <EXPR> `IS ODD'
            |     <EXPR> `IS IN' <RANGE> [`,' <RANGE>]*
            |     <EXPR> `IS NOT IN' <RANGE> [`,' <RANGE>]*

<RANGE>   ::=   `{' <EXPR> [`,' <EXPR>]* [`, ... ,' <EXPR>] `}'
          |     `{' <EXPR> [`FOR EACH' <IDENT> `IN' <RANGE> [`,' <RANGE>]* ]+
                [`WHERE' <REL_EXPR>] `}'

<RESTRICTED_IDENT>   ::=   <IDENT> `SUCH THAT' <REL_EXPR>

<SOURCE_TASK>   ::=   `ALL TASKS'
                |     `ALL TASKS' <IDENT>
                |     `TASK' <EXPR>
                |     `TASKS' <RESTRICTED_IDENT>
                |     `TASK' `GROUP' <IDENT>

<TARGET_TASKS>   ::=   `ALL OTHER TASKS'
                 |     `TASK' <EXPR>
                 |     `TASKS' <RESTRICTED_IDENT>
                 |     `TASK' `GROUP' <IDENT>

<MESSAGE_SPEC>        ::=   <ITEM_COUNT>
                            [`NONUNIQUE' | `UNIQUE']
                            <ITEM_SIZE>
                            [`UNALIGNED' |
                            <MESSAGE_ALIGNMENT> `ALIGNED' |
                            <MESSAGE_ALIGNMENT> `MISALIGNED']
                            `MESSAGES'
                            [`WITH VERIFICATION' | `WITH DATA TOUCHING' |
                            `WITHOUT VERIFICATION' | `WITHOUT DATA TOUCHING']
                            [`USING TAG'
                            <EXPR> | <STRING>]
                            [`FROM' [<EXPR> <DATA_MULTIPLIER> `INTO']
                            `BUFFER' <EXPR> | `THE DEFAULT BUFFER']

<RECV_MESSAGE_SPEC>   ::=   [`SYNCHRONOUSLY' | `ASYNCHRONOUSLY']
                            [`AS' [`A'|`AN']
                            [`NONUNIQUE' | `UNIQUE']
                            [`UNALIGNED' |
                            <MESSAGE_ALIGNMENT> `ALIGNED' |
                            <MESSAGE_ALIGNMENT> `MISALIGNED']
                            `MESSAGES']
                            [`WITH VERIFICATION' | `WITH DATA TOUCHING' |
                            `WITHOUT VERIFICATION' | `WITHOUT DATA TOUCHING']
                            [`USING TAG'
                            <EXPR> | <STRING>]
                            [`INTO' [<EXPR> <DATA_MULTIPLIER> `INTO']
                            `BUFFER' <EXPR> | `THE DEFAULT BUFFER']

<REDUCE_MESSAGE_SPEC>   ::=   <ITEM_COUNT>
                              [`NONUNIQUE' | `UNIQUE']
                              [`UNALIGNED' |
                              <MESSAGE_ALIGNMENT> `ALIGNED' |
                              <MESSAGE_ALIGNMENT> `MISALIGNED']
                              `INTEGERS' | `DOUBLEWORDS'
                              [`WITH DATA TOUCHING' | `WITHOUT DATA TOUCHING']
                              [`USING TAG'
                              <EXPR> | <STRING>]
                              [`FROM' [<EXPR> <DATA_MULTIPLIER> `INTO']
                              `BUFFER' <EXPR> | `THE DEFAULT BUFFER']

<REDUCE_TARGET_MESSAGE_SPEC>   ::=   [`AS' <ITEM_COUNT>
                                     [`NONUNIQUE' | `UNIQUE']
                                     [<MESSAGE_ALIGNMENT> `ALIGNED' |
                                     <MESSAGE_ALIGNMENT> `MISALIGNED']
                                     `INTEGERS' | `DOUBLEWORDS']
                                     [`WITH DATA TOUCHING' | `WITHOUT DATA TOUCHING']
                                     [`USING TAG'
                                     <EXPR> | <STRING>]
                                     [`INTO' [<EXPR> <DATA_MULTIPLIER> `INTO']
                                     `BUFFER' <EXPR> | `THE DEFAULT BUFFER']

<ITEM_COUNT>   ::=   `A' | `AN' | <EXPR>

<ITEM_SIZE>   ::=   <empty>
              |     <EXPR> <DATA_MULTIPLIER>
              |     <DATA_TYPE> `SIZED'

<DATA_MULTIPLIER>   ::=   `BIT' | `BYTE' | `HALFWORD' | `WORD' |      `INTEGER' |
                          `DOUBLEWORD' | `QUADWORD' | `PAGE' |      `KILOBYTE' | `MEGABYTE'
                          | `GIGABYTE'

<DATA_TYPE>   ::=   `BYTE' | `HALFWORD' | `WORD' |      `INTEGER' |
                    `DOUBLEWORD' | `QUADWORD' | `PAGE'

<MESSAGE_ALIGNMENT>   ::=   <DATA_TYPE>
                      |     <EXPR> <DATA_MULTIPLIER>

<SEND_STMT>   ::=   <SOURCE_TASK>
                    [`ASYNCHRONOUSLY'] `SENDS'
                    <MESSAGE_SPEC>
                    `TO' [`UNSUSPECTING'] <TARGET_TASKS>
              |     <SOURCE_TASK>
                    [`ASYNCHRONOUSLY'] `SENDS'
                    <MESSAGE_SPEC>
                    `TO' <TARGET_TASKS>
                    `WHO RECEIVE IT'
                    <RECV_MESSAGE_SPEC>

<RECEIVE_STMT>   ::=   <TARGET_TASKS>
                       [`ASYNCHRONOUSLY'] `RECEIVE'
                       <MESSAGE_SPEC>
                       `FROM' <SOURCE_TASK>

<WAIT_STMT>   ::=   <SOURCE_TASK>
                    `AWAITS COMPLETION'

<MCAST_STMT>    ::=   <SOURCE_TASK>
                      [`ASYNCHRONOUSLY'] `MULTICASTS'
                      <MESSAGE_SPEC>
                      `TO' <TARGET_TASKS>

<REDUCE_STMT>   ::=   <SOURCE_TASK>
                      `REDUCES'
                      <REDUCE_MESSAGE_SPEC>
                      `TO' <SOURCE_TASK>
                      [`WHO RECEIVES THE RESULT' <REDUCE_TARGET_MESSAGE_SPEC>]
                |     <SOURCE_TASK>
                      `REDUCES'
                      <REDUCE_MESSAGE_SPEC>
                      [`TO' <REDUCE_MESSAGE_SPEC>]

<SYNC_STMT>   ::=   <SOURCE_TASK>
                    `SYNCHRONIZES'

<STRING_OR_LOG_COMMENT>   ::=   <STRING>
                          |     `THE VALUE OF' <STRING>

<OUTPUT_STMT>   ::=   <SOURCE_TASK>
                      `OUTPUTS'
                      <EXPR> | <STRING_OR_LOG_COMMENT>
                      [`AND'   <EXPR> | <STRING_OR_LOG_COMMENT>]*

<LOG_STMT>   ::=   <SOURCE_TASK>
                   `LOGS'
                   <AGGR_EXPR> `AS' <STRING_OR_LOG_COMMENT>
                   [`AND' <AGGR_EXPR> `AS' <STRING_OR_LOG_COMMENT>]*

<FLUSH_STMT>   ::=   <SOURCE_TASK>
                     `COMPUTES AGGREGATES'

<RESET_STMT>   ::=   <SOURCE_TASK>
                     `RESETS ITS COUNTERS'

<STORE_STMT>   ::=   <SOURCE_TASK>
                     `STORES ITS COUNTERS'

<RESTORE_STMT>   ::=   <SOURCE_TASK>
                       `RESTORES ITS COUNTERS'

<COMPLEX_STMT>   ::=   <SIMPLE_STMT> [`THEN' <COMPLEX_STMT>]

<SIMPLE_STMT>   ::=   `FOR' <EXPR> `REPETITIONS'   [`PLUS' <EXPR> `WARMUP' `REPETITIONS'
                       [`AND A SYNCHRONIZATION']]   <SIMPLE_STMT>
                |      `FOR EACH' <IDENT> `IN' <RANGE>   [`,' <RANGE>]* <SIMPLE_STMT>
                |      `FOR' <EXPR> <TIME_UNIT> <SIMPLE_STMT>
                |      `LET' <LET_BINDING> [`AND' <LET_BINDING>]*   `WHILE'
                      <SIMPLE_STMT>
                |      `IF' <REL_EXPR> `THEN' <SIMPLE_STMT>   [`OTHERWISE'
                      <SIMPLE_STMT>]
                |     `{' [<COMPLEX_STMT>] `}'
                |     <SEND_STMT>
                |     <RECEIVE_STMT>
                |     <WAIT_STMT>
                |     <MCAST_STMT>
                |     <REDUCE_STMT>
                |     <SYNC_STMT>
                |     <OUTPUT_STMT>
                |     <LOG_STMT>
                |     <FLUSH_STMT>
                |     <RESET_STMT>
                |     <STORE_STMT>
                |     <RESTORE_STMT>
                |     <ASSERT_STMT>
                |     <DELAY_STMT>
                |     <TOUCH_STMT>
                |     <TOUCH_BUFFER_STMT>
                |     <PROCESSOR_STMT>
                |     <BACKEND_STMT>

<LET_BINDING>   ::=   <IDENT> `BE'       expr
                                     |   <SOURCE_TASK>
                                     |   `A RANDOM TASK' [<RANDOM_TASK_CONSTRAINTS>]

<RANDOM_TASK_CONSTRAINTS>   ::=   `OTHER THAN' <EXPR>
                            |     `LESS THAN' <EXPR> [`BUT NOT' <EXPR>]
                            |     `GREATER THAN' <EXPR> [`BUT NOT' <EXPR>]
                            |     `IN' `[' <EXPR> `,' <EXPR> `]' [`BUT NOT' <EXPR>]

<IF_STMT>   ::=   `IF' <REL_EXPR>
                  `THEN' <SIMPLE_STMT>
                  [`OTHERWISE' <SIMPLE_STMT>]

<ASSERT_STMT>   ::=   `ASSERT THAT' <STRING>
                      `WITH' <REL_EXPR>

<DELAY_STMT>   ::=   <SOURCE_TASK>
                     `SLEEPS' | `COMPUTES'
                     `FOR' <EXPR> <TIME_UNIT>

<TIME_UNIT>   ::=   `MICROSECONDS' | `MILLISECONDS' | `SECONDS' |      `MINUTES' | `HOURS' |
                    `DAYS'

<TOUCH_STMT>   ::=   <SOURCE_TASK>
                     `TOUCHES'
                     [<EXPR> <DATA_TYPE> `OF']
                     `AN' <ITEM_SIZE> `MEMORY REGION'
                     [<EXPR> `TIMES']
                     [`WITH STRIDE' <EXPR> <DATA_TYPE> | `WITH RANDOM STRIDE']

<TOUCH_BUFFER_STMT>   ::=   <SOURCE_TASK>
                            `TOUCHES'
                            `ALL MESSAGE BUFFERS'
                            | `MESSAGE BUFFER' <EXPR>
                            | `THE CURRENT MESSAGE BUFFER'

<PROCESSOR_STMT>   ::=   <SOURCE_TASK>
                         `IS ASSIGNED TO'
                         `PROCESSOR' <EXPR> | `A RANDOM PROCESSOR'

<BACKEND_STMT>   ::=   <SOURCE_TASK>
                       `BACKEND EXECUTES'
                       <EXPR> | <STRING>
                       [`AND' <EXPR> | <STRING>]*

<VERSION_DECL>   ::=   `REQUIRE LANGUAGE VERSION' <STRING>

<PARAM_DECL>   ::=   <IDENT>
                     `IS' <STRING>
                     `AND COMES FROM' <STRING> `OR' <STRING>
                     `WITH DEFAULT' <EXPR>

<BACKEND_DECL>   ::=   `THE BACKEND DECLARES' <STRING>

<PROGRAM>   ::=   (<VERSION_DECL> | <PARAM_DECL> | <BACKEND_DECL> [`.'])*
                  (<TOP_LEVEL_COMPLEX_STMT> [`.'])+

<TOP_LEVEL_COMPLEX_STMT>   ::=   <COMPLEX_STMT>


   The primitives <IDENT>, <STRING>, and <INTEGER> are described in
*note Primitives::.


File: conceptual.info,  Node: Examples,  Next: Implementation,  Prev: Grammar,  Up: Top

5 Examples
**********

This chapter presents a variety of examples of complete CONCEPTUAL
programs.  The purpose is to put in context the grammatical elements
described in *note Grammar:: and also to illustrate CONCEPTUAL's power
and expressiveness.

* Menu:

* Latency::                     Measure half the round-trip message latency
* Hot potato::                  Send a message around a ring
* Hot spot::                    Bombard task 0 with messages
* Multicast trees::             Multicast over various k-nomial trees
* Calling MPI functions::       Invoking MPI_Allgather() from coNCePTuaL


File: conceptual.info,  Node: Latency,  Next: Hot potato,  Prev: Examples,  Up: Examples

5.1 Latency
===========

One of the most common network performance benchmarks is a ping-pong
latency test.  Not surprisingly, such a test is straightforward to
implement in CONCEPTUAL:

     # A ping-pong latency test written in coNCePTuaL

     Require language version "1.4".

     # Parse the command line.
     reps is "Number of repetitions of each message size" and comes from
      "--reps" or "-r" with default 1000.
     maxbytes is "Maximum number of bytes to transmit" and comes from
      "--maxbytes" or "-m" with default 1M.

     # Ensure the we have a peer with whom to communicate.
     Assert that "the latency test requires at least two tasks" with
       num_tasks>=2.

     # Perform the benchmark.
     For each msgsize in {0}, {1, 2, 4, ..., maxbytes} {
       for reps repetitions {
         task 0 resets its counters then
         task 0 sends a msgsize byte message to task 1 then
         task 1 sends a msgsize byte message to task 0 then
         task 0 logs the msgsize as "Bytes" and
                     the median of elapsed_usecs/2 as "1/2 RTT (usecs)"
       } then
       task 0 computes aggregates
     }

   Note that the outer `FOR' loop specifies two <RANGE>s (*note Range
expressions::).  This is because `{0, 1, 2, 4, ..., maxbytes}' is not a
geometric progression.  Hence, that incorrect <RANGE> is split into the
singleton `{0}' and the geometric progression `{1, 2, 4, ...,
maxbytes}'.


File: conceptual.info,  Node: Hot potato,  Next: Hot spot,  Prev: Latency,  Up: Examples

5.2 Hot potato
==============

One way to measure performance variance on a parallel system is with a
"hot potato" test.  The idea is that the tasks send a message in a ring
pattern, then the first task logs the minimum, mean, and variance of
the per-hop latency.  Ideally, the minimum should equal the mean and
these should both maintain a constant value as the number of tasks
increases.  Also, the variance should be small and constant.  The
following CONCEPTUAL code implements a hot-potato test.

     # Virtual ring "hot potato" test

     Require language version "1.4".

     trials is "Number of trials to perform" and comes from "--trials" or
       "-t" with default 100000.

     Assert that "the hot-potato test requires at least two tasks" with
       num_tasks>=2.

     Let len be 0 while {
       for each task_count in {2, ..., num_tasks} {
         task 0 outputs "Performing " and trials and " " and
                        task_count and "-task runs...." then
         for trials repetitions plus 5 warmup repetitions {
           task 0 resets its counters then
           task 0 sends a len byte message to unsuspecting task 1 then
           task (n+1) mod task_count receives a len byte message from task
             n such that n<task_count then
           task n such that n>0 /\ n<task_count sends a len byte message
             to unsuspecting task (n+1) mod task_count then
           task 0 logs the task_count as "# of tasks" and
                       the minimum of elapsed_usecs/task_count as
                         "Latency (usecs)" and
                       the mean of elapsed_usecs/task_count as
                         "Latency (usecs)" and
                       the variance of elapsed_usecs/task_count as
                         "Latency (usecs)"
         } then
         task 0 computes aggregates
       }
     }

   All tasks receive from their left neighbor and send to their right
neighbor.  However, in order to avoid a deadlock situation, task 0
sends then receives while all of the other tasks receive then send.


File: conceptual.info,  Node: Hot spot,  Next: Multicast trees,  Prev: Hot potato,  Up: Examples

5.3 Hot spot
============

Different systems react differently to resource contention.  A hot-spot
test attempts to measure the performance degradation that occurs when a
task is flooded with data.  That is, all tasks except 0 concurrently
send a batch of messages to task 0.  Task 0 reports the incoming
bandwidth, i.e., the number of bytes it received divided by the time it
took to receive that many bytes.  The two independent variables are the
message size and the number of tasks.

     # Hot-spot bandwidth

     Require language version "1.4".

     maxbytes is "Maximum message size in bytes" and comes from
       "--maxbytes" or "-x" with default 1024.
     numtrials is "Number of bursts of each size" and comes from "--trials"
       or "-t" with default 100.
     burst is "Number of messages in each burst" and comes from
       "--burstsize" or "-b" with default 1000.

     Assert that "the hot-spot test requires at least two tasks" with
       num_tasks>=2.

     For each maxtask in {2, ..., num_tasks}
       for each msgsize in {1, 2, 4, ..., maxbytes} {
         task 0 outputs "Performing " and numtrials and " " and
                        maxtask and "-task trials with " and
                        msgsize and "-byte messages" then
         for numtrials repetitions plus 3 warmup repetitions {
           task 0 resets its counters then
           task sender such that sender>0 /\ sender<maxtask asynchronously
             sends burst msgsize byte messages to task 0 then
           all tasks await completion then
           task 0 logs the maxtask as "Tasks" and
                       the msgsize as "Message size (B)" and
                       the mean of (1E6*bytes_received)/(1M*elapsed_usecs)
                         as "Incoming BW (MB/s)"
         } then
         task 0 computes aggregates
       }


File: conceptual.info,  Node: Multicast trees,  Next: Calling MPI functions,  Prev: Hot spot,  Up: Examples

5.4 Multicast trees
===================

It may be worth comparing the performance of a native multicast
operation to the performance achieved by multicasting over a K-nomial
tree to gauge how well the underlying communication layer implements
multicasts.  The following code records a wealth of data, varying the
tree arity (i.e., K), the number of tasks receiving the multicast, and
the message size.  It provides a good demonstration of how to use the `KNOMIAL_CHILDREN'
and `KNOMIAL_CHILD' functions.

     # Test the performance of multicasting over various k-nomial trees
     # By Scott Pakin <pakin@lanl.gov>

     Require language version "1.4".

     # Parse the command line.
     minsize is "Min. message size (bytes)" and comes from "--minbytes" or "-n"
       with default 1.
     maxsize is "Max. message size (bytes)" and comes from "--maxbytes" or "-x"
       with default 1M.
     reps is "Repetitions to perform" and comes from "--reps" or "-r" with
       default 100.
     maxarity is "Max. arity of the tree" and comes from "--maxarity" or "-a"
       with default 2.

     Assert that "this program requires at least two processors" with
       num_tasks>=2.

     # Send messages from task 0 to 1, 2, 3, ... other tasks in a k-nomial tree.
     For each arity in {2, ..., maxarity} {
       for each num_targets in {1, ..., num_tasks-1} {
         for each msgsize in {minsize, minsize*2, minsize*4, ..., maxsize} {
           task 0 outputs "Multicasting a " and msgsize and "-byte message to "
             and num_targets and " target(s) over a " and arity and
             "-nomial tree ..." then
           for reps repetitions {
             task 0 resets its counters then
             for each src in {0, ..., num_tasks}
               for each dstnum in {0, ..., knomial_children(src, arity,
                   num_targets+1)}
                 task src sends a msgsize byte message to task
                   knomial_child(src, dstnum, arity) then
             all tasks synchronize then
             task 0 logs the arity as "k-nomial arity" and
                         the num_targets as "# of recipients" and
                         the msgsize as "Message size (bytes)" and
                         the median of (1E6/1M)*(msgsize/elapsed_usecs) as
                           "Incoming bandwidth (MB/s)" and
                         the median of (num_targets*msgsize/elapsed_usecs)*
                           (1E6/1M) as "Outgoing bandwidth (MB/s)"
           } then
           task 0 computes aggregates
         }
       }
     }


File: conceptual.info,  Node: Calling MPI functions,  Prev: Multicast trees,  Up: Examples

5.5 Calling MPI functions
=========================

The CONCEPTUAL language is designed to be highly portable.  Any
CONCEPTUAL program can be compiled using any of the backends listed in
*note Supplied backends::.  A consequence of this portability is that
CONCEPTUAL does not include primitives that are specific to any
particular target language or communication library.

   The `BACKEND EXECUTES' and `BACKEND DECLARES' statements (*note
Injecting arbitrary code::, and *note Backend-specific declarations::)
give a programmer the ability to sacrifice portability for the ability
to measure the performance of features provided by a specific target
language or communication library.  Hence, it is possible to write the
core parts of a benchmark in a lower-level language while letting
CONCEPTUAL handle the setup, measurement, logging, and other mundane
operations.

   The following program uses `BACKEND EXECUTES' to measure the
performance of the `MPI_Allgather()' function provided by an MPI
library.  Because it utilizes C code to call an MPI function, the code
builds only with the `c_mpi' backend.

     # Measure the performance of MPI_Allgather()
     # By Scott Pakin <pakin@lanl.gov>
     #
     # N.B. Requires the c_mpi backend.

     Require language version "1.4".

     # Parse the command line.
     numwords is "Message size (words)" and comes from "--msgsize" or "-s" with
     default 1.

     # Allocate a send buffer and a receive buffer.
     Task 0 multicasts a numwords-word message from buffer 0 to all other tasks.
     Task 0 multicasts a numwords*num_tasks word message from buffer 1 to all
     other tasks.

     # Measure the performance of MPI_Allgather().
     Task 0 resets its counters then
     for 100 repetitions plus 3 warmup repetitions
       all tasks backend execute "
         MPI_Allgather([MESSAGE BUFFER 0], (int)" and numwords and ", MPI_INT,
                       [MESSAGE BUFFER 1], (int)" and numwords and ", MPI_INT,
                       MPI_COMM_WORLD);
       " then
     task 0 logs elapsed_usecs/100 as "Gather time (us)".

   The preceding code demonstrates a few useful techniques:

   * A pair of `MULTICASTS' statements (*note Multicasting::) are used
     to allocate the two message buffers.

   * The `BACKEND EXECUTE' statement uses a value provided on the
     command line (`numwords', via `--msgsize') in the call to `MPI_Allgather()'.

   * Pointers to the two message buffers are passed to `MPI_Allgather()'
     using the `[MESSAGE BUFFER EXPR]' substitution described in *note
     Injecting arbitrary code::.


File: conceptual.info,  Node: Implementation,  Next: Tips and Tricks,  Prev: Examples,  Up: Top

6 Implementation
****************

CONCEPTUAL could have been implemented as a benchmarking library instead
of as a special-purpose language.  In addition to improved readability
and the practicality of including entire source programs in every log
file, one advantage of the language approach is that the same CONCEPTUAL
source code can be used to compare the performance of multiple
communication libraries.  A compiler command-line option selects a
particular backend module to use to generate code.  Each backend
outputs code for a different combination of low-level language and
communication library.

   The CONCEPTUAL compiler is structured into a pipeline of modules.
Thus, the backend can be replaced without altering the front end,
lexer, or parser modules.  CONCEPTUAL ensures consistency across
backends by providing a run-time library that generated code can link
to.  The run-time library encapsulates many of the mundane tasks a
network correctness or performance test needs to perform.

* Menu:

* Overview::                    Summary of coNCePTuaL's construction
* Backend creation::            How to write a new compiler backend
* Run-time library functions::  Description of functions used by backends


File: conceptual.info,  Node: Overview,  Next: Backend creation,  Prev: Implementation,  Up: Implementation

6.1 Overview
============

* Menu:

* Compiler::                    Components of the coNCePTuaL compiler
* Run-time library::            The library commonly linked to generated programs
* Build process::               How coNCePTuaL itself is configured and built


File: conceptual.info,  Node: Compiler,  Next: Run-time library,  Prev: Overview,  Up: Overview

Compiler
--------

The CONCEPTUAL compiler is written in Python and is based on the PLY
(Python Lex-Yacc) compiler framework.  Compiler execution follows a
basic pipeline structure.  Compilation starts with the top-level file (`ncptl.py'),
which processes the command line then transfers control to the lexer (`ncptl_lexer.py').
The lexer inputs CONCEPTUAL source code and outputs a stream of tokens (`ncptl_token.py').
Next, the parser (`ncptl_parser.py') finds structure in those tokens
based on CONCEPTUAL's grammatical rules and outputs an abstract syntax
tree (`ncptl_ast.py').  Finally, the code generator (`codegen_LANGUAGE_LIBRARY.py')
that was designated on the command line walks the abstract syntax tree,
converting it to code in the target language and for the target
communication library.


File: conceptual.info,  Node: Run-time library,  Next: Build process,  Prev: Compiler,  Up: Overview

Run-time library
----------------

CONCEPTUAL makes a large run-time library (`runtimelib.c') available to
generated programs.  The CONCEPTUAL run-time library, which is written
in C, provides consistent functionality across target languages and
communication layers as well as across hardware architectures and
operating systems.  The library also simplifies code generation by
implementing functions for such tasks as memory allocation, queue
management, and data logging.  The functions in this library are
described in *note Run-time library functions::.


File: conceptual.info,  Node: Build process,  Prev: Run-time library,  Up: Overview

Build process
-------------

CONCEPTUAL is built using the GNU Autotools (Autoconf, Automake, and Libtool).
Consequently, changes should be made to original files, not generated
files.  Specifically, `configure.ac' and `acinclude.m4' should be edited
in place of `configure'; `ncptl.h.in' should be edited in place of `ncptl.h';
and, the various `Makefile.am' files should be edited in place of the
corresponding `Makefile's.  For information about how these various
tools operate, *note (autoconf)Top::, *note (automake)Top::, and *note
(libtool)Top::.

   If `configure' is given the `--enable-maintainer-mode' option, `make'
will automatically re-run `aclocal', `autoheader', `automake', `autoconf',
and/or `./configure ' as needed.  Developers who plan to modify any of
the "maintainer" files (`acinclude.m4', `configure.ac', and the various `Makefile.am'
files) are strongly encouraged to configure CONCEPTUAL with `--enable-maintainer-mode'
in order to ensure that the build process is kept current with any
changes.


File: conceptual.info,  Node: Backend creation,  Next: Run-time library functions,  Prev: Overview,  Up: Implementation

6.2 Backend creation
====================

The CONCEPTUAL compiler's backend generates code from an abstract syntax
tree (AST).  The compiler was designed to support a variety of code
generators, each targeting a particular programming language and
communication library.  There are two ways to create a new CONCEPTUAL
backend.  Either a `codegen_LANGUAGE_LIBRARY.py' backend supporting an
arbitrary language and communication library can be written from
scratch or a C-based `codegen_c_LIBRARY.py' backend can be derived from `codegen_c_generic.py'.

   In the former case, the backend must define an `NCPTL_CodeGen'
class.  `NCPTL_CodeGen' class must contain a `generate' method with the
following signature:

     def generate(self, ast, filesource='<stdin>', filetarget='-',
                  sourcecode=None):

That is, `generate' takes as arguments a class object, the root of an
abstract-syntax tree (as defined in `ncptl_ast.py'), the name of the
input file containing CONCEPTUAL code (to be used for outputting error
messages), the name of the output file to produce, and the complete
CONCEPTUAL source code (which is both stored in prologue comments and
passed to the run-time library).  `generate' should invoke
`self.postorder_traversal' to traverse the AST in a post-order fashion,
calling various code-generating methods as it proceeds.  The `NCPTL_CodeGen'
must implement all of the methods listed in *note Method calls::, each
of which corresponds to some component of the CONCEPTUAL grammar.  Each
method takes a "self" class object an a node of the AST (of type `AST').

   The compiler front-end, `ncptl', invokes the following two methods,
which must be defined by the backend's `NCPTL_CodeGen' class:

     def compile_only(self, progfilename, codelines, outfilename,
                      verbose, keepints):

     def compile_and_link(self, progfilename, codelines, outfilename,
                          verbose, keepints):

The `compile_only' method compiles the backend-specific code into an
object file.  The `compile_and_link' method compiles the
backend-specific code into an object file and links it into an
executable file.  For some backends, the notions of "compile" and
"link" may not be appropriate.  In that situation, the backend should
perform the closest meaningful operations.  For example, the `dot_ast'
backend (*note The dot_ast backend::) compiles to a `.dot' file and
links into the target graphics format (`.ps' by default).

   For both the `compile_only' and `compile_and_link' methods,
`progfilename' is the name of the CONCEPTUAL input file specified on
the `ncptl' command line or the string `<command line>' if a program
was specified literally with `--program'.  `codelines' is the output
from the `generate' method, i.e., a list of lines of backend-specific
code.  `outfilename' is the name of the target file specified on the `ncptl'
command line with `--output' or the string `-' if `--output' was not
used.  If `verbose' is `1', the method should write each operation it
plans to perform to the standard-error device.  For consistency,
comment lines should begin with `#'; shell commands should be output
verbatim.  If `verbose' is `0', corresponding to the `ncptl' `--quiet'
option, the method should output nothing but error messages.  Finally,
`keepints' corresponds to the `--keep-ints' option to `ncptl'.  If
equal to `0', all intermediate files should be deleted before
returning; if equal to `1', intermediate files should be preserved.
*Note Compiling coNCePTuaL programs::, for a description of the various
command-line options to `ncptl'.

   As long as `NCPTL_CodeGen' implements all of the required functions
it is free to generate code in any way that it sees fit.  However,
*note Method calls::, lists a large number of methods, many of which
will be identical across multiple code generators for the same language
but different communication libraries.  To simplify a common case, C
plus some messaging library, CONCEPTUAL provides `codegen_c_generic.py',
to which the remainder of the Implementation chapter is devoted to
explaining.

* Menu:

* Hook methods::                Injecting code at strategic locations
* A minimal C-based backend::   How to write a trivial, sequential-only backend
* Generated code::              The generated C code's basic structure
* Internals::                   Key parts of codegen_c_generic.py


File: conceptual.info,  Node: Hook methods,  Next: A minimal C-based backend,  Prev: Backend creation,  Up: Backend creation

6.2.1 Hook methods
------------------

Multiple code generators for the same language but different
communication libraries are apt to contain much code in common.
Because C is a popular language, CONCEPTUAL provides a `codegen_c_generic.py'
module that implements a virtual `NCPTL_CodeGen' base class.  This base
class implements all of the methods listed in *note Method calls::.
However, rather than support a particular communication library, the `codegen_c_generic.py'
implementation of `NCPTL_CodeGen' merely provides a number of calls to
"hook" methods--placeholders that implement library-specific
functionality.  *Note C hooks::, for a list of all of the hooks that `codegen_c_generic.py'
defines.  For clarity, hooks are named after the method from which
they're called but with an all-uppercase tag appended.  Hook methods
take a single parameter, a read-only dictionary (the result of invoking Python's `locals()'
function) of all of the local variables in the caller's scope.  They
return C code in the form of a list with one line of C per element.  A
hook method is invoked only if it exists, which gives the backend
developer some flexibility in selecting places at which to insert code.
Of course, for coarser-grained control, a backend developer can override
complete methods in `codegen_c_generic.py' if desired.  Generally, this
will not be necessary as hook invocations are scattered liberally
throughout the file.

An example
..........

`codegen_c_generic.py' defines a method named `code_specify_include_files'.
(`codegen_c_generic.py' names all of its code-generating helper methods
`code_SOMETHING'.)  `code_specify_include_files' pushes a sequence of `#include'
directives onto a queue of lines of C code.  The method is shown below
in its entirety:

     def code_specify_include_files(self, node):
         "Load all of the C header files the generated code may need."

         # Output a section comment.
         self.pushmany([
             "/*****************",
             " * Include files *",
             " *****************/",
             ""])

         # Enable hooks both before and after the common includes.
         self.pushmany(self.invoke_hook("code_specify_include_files_PRE",
                                        locals(),
                                        before=[
             "/* Header files specific to the %s backend */" %
             self.backend_name],
                                        after=[""]))
         self.pushmany([
             "/* Header files needed by all C-based backends */",
             "#include <stdio.h>",
             "#include <string.h>",
             "#include <ncptl/ncptl.h>"])
         self.pushmany(self.invoke_hook("code_specify_include_files_POST",
                                        locals(),
                                        before=[
             "",
             "/* Header files specific to the %s backend */" %
             self.backend_name]))

   `code_specify_include_files' uses the `pushmany' method (*note
Internals::) to push each element in a list of lines of C code onto the
output queue.  It starts by pushing a section comment--`codegen_c_generic.py'
outputs fully commented C code.  Next, it invokes the `code_specify_include_files_PRE'
hook if it exists and pushes that method's return value onto the queue.
Then, it pushes all of the `#include's needed by the generated C code.
Finally, it invokes the `code_specify_include_files_POST' hook if it
exists and pushes that method's return value onto the queue.

   A backend that requires additional header files from those included
by `code_specify_include_files' need only define `code_specify_include_files_PRE'
to add extra header files before the standard ones or `code_specify_include_files_POST'
to add extra header files after them.  The following is a sample
(hypothetical) hook definition:

     def code_specify_include_files_POST(self, localvars):
         "Specify extra header files needed by the c_pthreads backend."
         return [
             "#include <errno.h>",
             "#include <pthread.h>"]

   Although the top-level structure of `codegen_c_generic.py' is
described in *note Internals::, a backend developer will normally need
to study the `codegen_c_generic.py' source code to discern the purpose
of each hook method and its relation to the surrounding code.


File: conceptual.info,  Node: A minimal C-based backend,  Next: Generated code,  Prev: Hook methods,  Up: Backend creation

6.2.2 A minimal C-based backend
-------------------------------

A backend derived from `codegen_c_generic.py' starts by defining an `NCPTL_CodeGen'
child class that inherits much of its functionality from the parent `NCPTL_CodeGen'
class.  There are only two items that a C-based backend _must_ define: `backend_name',
the name of the backend in the form `c_LIBRARY'; and, `backend_desc', a
brief phrase describing the backend.  (These are used for error
messages and file comments.)  Also, a backend's `__init__' method must
accept an `options' parameter, which is given a list of command-line
parameters not recognized by `ncptl.py'.  After `NCPTL_CodeGen''s `__init__'
method processes the entries in `options' that it recognizes, it should
pass the remaining options to its parent class's `__init__' method for
further processing.  (For proper initialization, the parent class's `__init__'
method must be called, even if there are no remaining options to
process.)

   The following is the complete source code to a minimal CONCEPTUAL
backend.  This backend, `codegen_c_seq.py', supports only sequential
CONCEPTUAL programs (e.g., `TASK 0 OUTPUTS "Hello, world!"'); any
attempt to use communication statements (*note Communication
statements::) will result in a compile-time error.

     #! /usr/bin/env python

     #######################################################
     # Code generation module for the coNCePTuaL language: #
     # Minimal C-based backend -- all communication        #
     # operations result in a compiler error               #
     #                                                     #
     # By Scott Pakin <pakin@lanl.gov>                     #
     #######################################################

     import codegen_c_generic

     class NCPTL_CodeGen(codegen_c_generic.NCPTL_CodeGen):
         def __init__(self, options):
             "Initialize the sequential C code generation module."
             self.backend_name = "c_seq"
             self.backend_desc = "C, sequential code only"
             codegen_c_generic.NCPTL_CodeGen.__init__(self, options)

             # We don't have our own command-line options but we handle
             # --help, nevertheless.
             for arg in range(0, len(options)):
                 if options[arg] == "--help":
                     # Output a help message.
                     self.show_help()
                     raise SystemExit, 0

   The `c_seq' backend can be used like any other:

     ncptl --backend=c_seq \
       --program='For each i in {10, ..., 1} task 0 outputs i.' | \
       indent > myprogram.c

(`codegen_c_generic.py' outputs unindented code, deferring attractive
formatting to the Unix `indent' utility.)

   One sequential construct the `c_seq' backend does not support is
randomness, as needed by`A RANDOM PROCESSOR' (*note Reordering task
IDs::) and `A RANDOM TASK' (*note Binding variables::).  `codegen_c_generic.py'
cannot support randomness itself because doing so requires broadcasting
the seed for the random-number generator to all tasks.  Broadcasting
requires messaging-layer support, which a derived backend provides
through the `code_def_init_reseed_BCAST' hook (*note Hook methods::).
For the sequential backend presented above, a broadcast can be
implemented as a no-op:

     def code_def_init_reseed_BCAST(self, localvars):
         '"Broadcast" a random-number seed to all tasks.'
         return []

   In fact, that same do-nothing hook method is used by the `c_udgram'
backend.  `c_udgram' seeds the random-number generator before calling `fork()',
thereby ensuring that all tasks have the same seed without requiring an
explicit broadcast.


File: conceptual.info,  Node: Generated code,  Next: Internals,  Prev: A minimal C-based backend,  Up: Backend creation

6.2.3 Generated code
--------------------

`codegen_c_generic.py' generates thoroughly commented C code.  However,
the overall structure of the generated code may be somewhat
unintuitive, as it does not resemble the code that a human would write
to accomplish a similar task.  The basic idea behind the generated C
code is that it expands the entire program into a list of "events",
then starts the clock, then executes all of the events in a single
loop.  Regardless of the CONCEPTUAL program being compiled, the body of
the generated C code will look like this:

     for (i=0; i<numevents; i++) {
       CONC_EVENT *thisev = &eventlist[i];

       switch (thisev->type) {
         case EVENT_1:
                                             ...


     case EVENT_2:
                                             ...


     }
     }

   Programs generated by `codegen_c_generic.py' define a number of event
types that are summarized in *note Event types::.  The `EV_CODE' event
is used, for example, by the `BACKEND EXECUTES' (*note Injecting
arbitrary code::), `LOGS' (*note Writing to a log file::), and `OUTPUTS'
(*note Writing to standard output::) statements.  Note that there are
no loop events--in fact, there are no complex statements (*note Complex
statements::) whatsoever.  Complex statements are expanded into
multiple simple statements at initialization time.

   The advantage of completely expanding a CONCEPTUAL program during the
initialization phase--essentially, "pre-executing" the entire
program--is that that enables all of the expensive,
non-communication-related setup to be hoisted out of the timing loop,
which is how a human would normally express a network benchmark.
Pre-execution is possible because the CONCEPTUAL language is not a
Turing machine; infinite loops are not expressible by the language and
message contents and timings cannot affect program behavior, for
instance.  During its initialization phase, the generated C code
allocates memory for message buffers, evaluates numerical expressions,
verifies program assertions, unrolls loops, and does everything else
that's not directly relevant to communication performance.  For
instance, the CONCEPTUAL program `TASK tx SUCH THAT tx>4 SENDS 10 1
MEGABYTE MESSAGES TO TASK tx/2' would cause each task to perform the
following steps during initialization:

   * determine if its task ID is greater than 4, making the task a
     sender

   * determine if its task ID is equal to `tx/4' (rounded down to the
     nearest integer) for some task `tx' in the program, making the
     task a receiver

   * allocate 1MB for a message buffer

   * allocate and initialize a repeat event, specifying that the
     subsequent event should repeat 10 times

   * allocate a send or receive event

The final two of those steps repeat as necessary.  For example, task 3
receives 10 messages from each of task 6 and task 7.

   Note that each task's receive events (if any) are allocated before
its send events (if any), as described *note Sending::.  Also, note that
only a single message buffer is allocated because the CONCEPTUAL source
did not specify the `UNIQUE' keyword (*note Unique messages::).

   An event is implemented as a C `struct' that contains all of the
state needed to perform a particular operation.  For example, an event
corresponding to a synchronous or asynchronous send operation (`CONC_SEND_EVENT')
stores the destination task ID, the number of bytes to send, the
message alignment, the number of outstanding asynchronous sends and
receives, a flag indicating whether the data is to be touched, and a
flag indicating that the message should be filled with data the
receiver can verify.  In addition, the `code_declare_datatypes_SEND_STATE'
hook (*note Hook methods::) enables a backend to include additional,
backend-specific state in the (`CONC_SEND_EVENT') data structure.


File: conceptual.info,  Node: Internals,  Prev: Generated code,  Up: Backend creation

6.2.4 Internals
---------------

`codegen_c_generic.py' is a fairly substantial piece of code.  It is
divided into ten sections:

  1. methods exported to the compiler front end

  2. utility functions that do not generate code

  3. utility functions that do generate code

  4. methods for outputting language atoms (*note Primitives::)

  5. methods for outputting miscellaneous language constructs (e.g.,
     restricted identifiers; *note Restricted identifiers::)

  6. methods for outputting expressions (*note Expressions::)

  7. methods for outputting complete programs (*note Complete
     programs::)

  8. methods for outputting complex statements (*note Complex
     statements::)

  9. methods for outputting simple statements (e.g., communication
     statements; *note Communication statements::)

 10. methods for outputting nodes with non-textual names (e.g., `...'
     and various operators)

   The `NCPTL_CodeGen' class defined in `codegen_c_generic.py'
generates code as follows.  The `generate' method, which is invoked by `ncptl.py',
calls upon PLY to process the abstract-syntax tree (AST) in postorder
fashion.  `NCPTL_CodeGen' maintains a stack (`codestack') on which code
fragments are pushed and popped but that ends up containing a complete
line of C code in each element.  For example, in the CONCEPTUAL program
`TASK 0 OUTPUTS 1+2*3', the `n_outputs' method will pop `[('expr',
'(1)+((2)*(3))')]' (a list containing the single expression `1+2*3')
and `('task_expr', '0')' (a tuple designating a task by the expression
`0') and push multiple lines of code that prepare task 0 to evaluate
and output the given expression.

   The utility functions are the most useful for backend developers to
understand, as they are frequently called from hook methods (*note Hook
methods::).  The following should be of particular importance:

`push'
`pushmany'
     Push a single value (typically a string of C code) or each value
     in a list of values onto a stack.

`error_fatal'
`error_internal'
     Output a generic error message or an "internal error" error message
     and abort the program.

`code_declare_var'
     Push (using the `push' method) a line of C code that declares a
     variable with an optionally specified type, name, initial value,
     and comment.  Return the variable name actually used.

See the definitions in `codegen_c_generic.py' of each of the above to
determine required and optional parameters.  The following, adapted
from `codegen_c_udgram.py' demonstrates some of the preceding methods:

     def n_for_count_SYNC_ALL(self, localvars):
         "Synchronize all of the tasks in the job."
         synccode = []
         self.push("{", synccode)
         loopvar = self.code_declare_var(suffix="task",
           comment="Loop variable that iterates over all (physical) ranks",
           stack=synccode)
         self.pushmany([
           "thisev_sync->s.sync.peerqueue = ncptl_queue_init (sizeof(int));",
           "for (%s=0; %s<var_num_tasks; %s++)" %
           (loopvar, loopvar, loopvar),
           "*(int *)ncptl_queue_allocate(thisev_sync->s.sync.peerqueue) = %s;" %
           loopvar,
           "thisev_sync->s.sync.syncrank = physrank;",
           "}"],
                       stack=synccode)
         return synccode

   That definition of the `n_for_count_SYNC_ALL' hook method defines a
new stack (`synccode') and pushes a `{' onto it.  It then declares a
loop variable, letting `code_declare_var' select a name but dictating
that it end in `_task'.  The hook method then pushes some additional C
code onto the `synccode' stack and finally returns the stack (which is
really just a list of lines of C code).

   Some useful variables defined by `NCPTL_CodeGen' include the
following:

`base_global_parameters'
     a list of 6-ary tuples defining extra command-line parameters to
     parse (format: {TYPE, VARIABLE, LONG_NAME, SHORT_NAME,
     DESCRIPTION, DEFAULT_VALUE})

`events_used'
     a dictionary containing the names of events actually used by the
     program being compiled

   Some methods in `codegen_c_generic.py' that are worth understanding
but are unlikely to be used directly in a derived backend include the
following:

`pop'
     Pop a value from a stack.

`push_marker'
     Push a specially designated "marker" value onto a stack.

`combine_to_marker'
     Pop all items off a stack up to the first marker value found;
     discard the marker; then, push the popped items as a single list
     of items.  This is used, for example, by a complex statement
     (*note Complex statements::) that applies to a list of statements,
     which can be popped as a unit using `combine_to_marker'.

`invoke_hook'
     Call a hook method, specifying code to be pushed before/after the
     hook-produced code and alternative text (or Python code) to be
     pushed (or executed) in the case that a hook method is not
     provided.


File: conceptual.info,  Node: Run-time library functions,  Prev: Backend creation,  Up: Implementation

6.3 Run-time library functions
==============================

To simplify the backend developer's task and to provide consistent
functionality across backends, CONCEPTUAL provides a run-time library
that encapsulates many of the common operations needed for
network-correctness and performance-testing programs.  This section
describes all of the functions that the library exports (plus a few
important types and variables).  The library is written in C, so all of
the type/variable/function prototypes are expressed with C syntax.  The
library includes, among others, functions that manage heap-allocated
memory, accurately read the time, write results to log files, control
queues of arbitrary data, and implement various arithmetic operations.
All of these functions should be considered "slow" and should therefore
generally not be invoked while execution is being timed.(1)

* Menu:

* Variables and data types::    Non-functions used by backends and the library
* Initialization functions::    The first calls to make from C
* Memory-allocation functions::  Getting memory from the heap
* Message-buffer manipulation functions::  Managing communication buffers
* Time-related functions::      Measuring and consuming time
* Log-file functions::          Writing results to a log file
* Random-task functions::       Selecting tasks at random
* Task-mapping functions::      Mapping between task IDs and processor IDs
* Queue functions::             Manipulating data queues
* Unordered-set functions::     Manipulating unordered sets of data
* Language-visible functions::  Implementing coNCePTuaL functions
* Finalization functions::      Cleanly stopping the run-time library

   ---------- Footnotes ----------

   (1) Some notable exceptions are the functions described in *note
Message-buffer manipulation functions::, which implement CONCEPTUAL's `WITH
DATA TOUCHING' and `WITH VERIFICATION' constructs.


File: conceptual.info,  Node: Variables and data types,  Next: Initialization functions,  Prev: Run-time library functions,  Up: Run-time library functions

6.3.1 Constants, variables, and data types
------------------------------------------

The following constants, variables, and data types are used by various
run-time library functions and directly by backends.

 -- Data type: ncptl_int
     The internal data type of the CONCEPTUAL run-time library is `ncptl_int'.
     This is normally a 64-bit signed integer type selected
     automatically by `configure' (*note configure::) but can be
     overridden with the `--with-datatype' option to `configure'.  `ncptl.h'
     defines a string macro called `NICS' that can be used to output an `ncptl_int'
     regardless of how the `ncptl_int' type is declared:

          ncptl_fatal ("My variable contains a negative value (%" NICS ")",
                       my_ncptl_int_var);

     `ncptl_int' constants declared by backends derived from `codegen_c_generic.py'
     are given an explicit suffix that defaults to `LL' but can be
     overridden at configuration time using the `--with-const-suffix'
     option.

 -- Constant: NCPTL_INT_MIN
     `NCPTL_INT_MIN' is a C preprocessor macro that represents the
     smallest (i.e., most negative) number that can be assigned to an `ncptl_int'.
     For example, if `ncptl_int' is a 64-bit signed integer type, then `NCPTL_INT_MIN'
     will be the value `-9223372036854775808'.

 -- Data type: NCPTL_CMDLINE
     The `NCPTL_CMDLINE' structure describes an acceptable command-line
     option.  It contains a type, which is either `NCPTL_TYPE_INT' for
     an `ncptl_int' or `NCPTL_TYPE_STRING' for a `char *', a pointer to
     a variable that will receive the value specified on the command
     line, the long name of the argument (without the `--'), the
     one-letter short name of the argument (without the `-'), a textual
     description of what the argument represents, and a default value to
     use if the option is not specified on the command line.

 -- Data type: NCPTL_QUEUE
     An `NCPTL_QUEUE' is an opaque data type that represents a
     dynamically growing queue that can be flattened to an array for
     more convenient access.  `NCPTL_QUEUE's have proved to be quite
     useful when implementing CONCEPTUAL backends.

 -- Data type: NCPTL_LOG_FILE_STATE
     Every CONCEPTUAL log file is backed by a unique `NCPTL_LOG_FILE_STATE'
     opaque data type.  An `NCPTL_LOG_FILE_STATE' data type represents
     all of the state needed to maintain that file, such as file
     descriptors, prologue comments, and data that has not yet been
     aggregated.

 -- Variable: int ncptl_pagesize
     This variable is initialized by `ncptl_init()' to the number of
     bytes in an operating-system memory page.  `ncptl_pagesize' can be
     used by backends to implement CONCEPTUAL's `PAGE SIZED' (*note
     Item size::) and `PAGE ALIGNED' (*note Message alignment::)
     keywords.

 -- Variable: int ncptl_fast_init
     The `ncptl_init()' function (*note Initialization functions::) can
     take many seconds to complete.  Much of this time is spent
     calibrating and measuring the quality of the various timers the
     run-time library uses.  For backends such as `picl' (*note The
     picl backend::) that do not measure real time there is little need
     to have an accurate timer.  Setting `ncptl_fast_init' to `1'
     before invoking `ncptl_init()' skips the timer calibration and
     measurement steps, thereby leading to faster initialization times.
     A user can also override the setting of `ncptl_fast_init' at run
     time by setting the `NCPTL_FAST_INIT' environment variable to
     either `0' or `1', as appropriate.


File: conceptual.info,  Node: Initialization functions,  Next: Memory-allocation functions,  Prev: Variables and data types,  Up: Run-time library functions

6.3.2 Initialization functions
------------------------------

The following functions are intended to be called fairly early in the
generated code.

 -- Function: void ncptl_init (int VERSION, char *PROGRAM_NAME)
     Initialize the CONCEPTUAL run-time library.  VERSION is used to
     verify that `runtimelib.c' corresponds to the version of `ncptl.h'
     used by the generated code.  The caller must pass in `NCPTL_RUN_TIME_VERSION'
     for VERSION.  PROGRAM_NAME is the name of the executable program
     and is used for outputting error messages.  The caller should pass
     in `argv[0]' for PROGRAM_NAME.  `ncptl_init()' must be the first
     library function called by the generated code (with a few
     exceptions, as indicated below).

 -- Function: void ncptl_permit_signal (int SIGNALNUM)
     Indicate that the backend relies on signal SIGNALNUM for correct
     operation.  Because signal handling has performance implications,
     the CONCEPTUAL run-time library normally terminates the program
     upon receiving a signal.  Hence, the user can be assured that if a
     program runs to completion then no signals have affected its
     performance.  *Note Running coNCePTuaL programs::, for a
     description of the `--no-trap' command-line option, which enables
     a user to permit additional signals to be delivered to the program
     (e.g., when linking with a particular implementation of a
     communication library that relies on signals).  `ncptl_permit_signal()'
     must be invoked before `ncptl_parse_command_line()' to have any
     effect.

 -- Function: void ncptl_parse_command_line (int ARGC, char *ARGV[],
          NCPTL_CMDLINE *ARGLIST, int NUMARGS)
     Parse the command line.  ARGC and ARGV should be the argument
     count and argument vector passed to the generated code by the
     operating system.  ARGLIST is a list of descriptions of acceptable
     command-line arguments and NUMARGS is the length of that list.

   Because `ncptl_init()' takes many seconds to run, it is common for
generated code to scan the command line for `--help' or `-?' and, if
found, skip `ncptl_init()' and immediately invoke `ncptl_parse_command_line()'.
Doing so gives the user immediate feedback when requesting program
usage information.  Skipping `ncptl_init()' is safe in this context
because `ncptl_parse_command_line()' terminates the program after
displaying usage information; it does not require any information
discovered by `ncptl_init()'.

   Most generated programs have a `--seed'/`-S' option that enables the
user to specify explicitly a seed for the random-number generator with `--help'/`-?'
showing the default seed.  `ncptl_seed_random_task()' must therefore be
called before `ncptl_parse_command_line()' which, as stated in the
previous paragraph, can be invoked without a prior invocation of `ncptl_init()'.
Consequently, it can be considered safe also to invoke `ncptl_seed_random_task()'
before `ncptl_init()'.

   A generated program's initialization routine will generally exhibit a
structure based on the following pseudocode:

     *if* "`--help'" *or* "`-?'" *in* command-line options *then*
        ONLY_HELP := TRUE
     *else*
        ONLY_HELP := FALSE
        `ncptl_init(...)'
     *end if*
     RANDOM_SEED := `ncptl_seed_random_task(0)'
     `ncptl_parse_command_line(...)'
     *if* ONLY_HELP = TRUE *then*
        `ncptl_error("Internal error; should have exited")'
     *end if*
     `ncptl_seed_random_task(RANDOM_SEED)'


File: conceptual.info,  Node: Memory-allocation functions,  Next: Message-buffer manipulation functions,  Prev: Initialization functions,  Up: Run-time library functions

6.3.3 Memory-allocation functions
---------------------------------

The CONCEPTUAL run-time library provides its own wrappers for
`malloc()', `free()', `realloc()', and `strdup()' as well as a
specialized `malloc()' designed specifically for allocating message
buffers.  The wrappers' "value added" is that they support the explicit
data alignments needed by `ALIGNED' messages (*note Message
alignment::) and that they automatically call `ncptl_fatal()' on
failure, so the return value does not need to be checked for `NULL'.

 -- Function: void * ncptl_malloc (ncptl_int NUMBYTES, ncptl_int
          ALIGNMENT)
     Allocate NUMBYTES bytes of memory aligned to an ALIGNMENT-byte
     boundary.  If ALIGNMENT is `0', `ncptl_malloc()' will use whatever
     alignment is "natural" for the underlying architecture.  `ncptl_malloc()'
     will automatically call `ncptl_fatal()' if memory allocation fails.
     Therefore, unlike `malloc()', there is no need to check the return
     value for `NULL'.

 -- Function: void * ncptl_malloc_misaligned (ncptl_int NUMBYTES,
          ncptl_int MISALIGNMENT)
     Allocate NUMBYTES bytes of memory from the heap aligned
     MISALIGNMENT bytes past a page boundary.  If ALIGNMENT is `0', `ncptl_malloc_misaligned()'
     will return page-aligned memory.  `ncptl_malloc_misaligned()' will
     automatically call `ncptl_fatal()' if memory allocation fails.
     Therefore, unlike `malloc()', there is no need to check the return
     value for `NULL'.

 -- Function: void ncptl_free (void *POINTER)
     Free memory previously allocated by `ncptl_malloc()'.  It is an
     error to pass `ncptl_free()' memory not allocated by `ncptl_malloc()'.

 -- Function: void * ncptl_realloc (void *POINTER, ncptl_int NUMBYTES,
          ncptl_int ALIGNMENT)
     Given a pointer returned by `ncptl_malloc()', change its size to
     NUMBYTES and byte-alignment to ALIGNMENT without altering the
     contents (except for truncation in the case of a smaller target
     size).  If ALIGNMENT is `0', `ncptl_realloc()' will use whatever
     alignment is "natural" for the underlying architecture.  `ncptl_realloc()'
     will automatically call `ncptl_fatal()' if memory allocation
     fails.  Therefore, unlike `realloc()', there is no need to check
     the return value for `NULL'.

 -- Function: char * ncptl_strdup (const char *STRING)
     `ncptl_strdup()' copies a string as does the standard C `strdup()'
     function.  However, `ncptl_strdup()' uses `ncptl_malloc()' instead
     of `malloc()' to allocate memory for the copy, which must
     therefore be deallocated using `ncptl_free()'.

 -- Function: void * ncptl_malloc_message (ncptl_int NUMBYTES,
          ncptl_int ALIGNMENT, ncptl_int OUTSTANDING, int MISALIGNED)
     Allocate NUMBYTES bytes of memory from the heap either aligned on
     an ALIGNMENT-byte boundary (if MISALIGNED is `0') or ALIGNMENT
     bytes past a page boundary (if MISALIGNED is `1').  All calls with
     the same value of OUTSTANDING will share a buffer.  `ncptl_malloc_message()'
     is intended to be used in two passes.  The first time the function
     is called on a set of messages it merely determines how much
     memory to allocate.  The second time, it returns valid memory
     buffers.  Note that the returned pointer can be neither `free()'d
     nor `ncptl_free()'d.

 -- Function: void * ncptl_get_message_buffer (ncptl_int BUFFERNUM)
     Return a pointer to a message buffer previously allocated (and
     finalized) by `ncptl_malloc_message()'.  The BUFFERNUM argument to `ncptl_get_message_buffer()',
     which corresponds to the OUTSTANDING argument to `ncptl_malloc_message()',
     specifies the number of the buffer to return.  `ncptl_get_message_buffer()'
     returns `NULL' if buffer BUFFERNUM is either unallocated or
     uninitialized.


File: conceptual.info,  Node: Message-buffer manipulation functions,  Next: Time-related functions,  Prev: Memory-allocation functions,  Up: Run-time library functions

6.3.4 Message-buffer manipulation functions
-------------------------------------------

The CONCEPTUAL language facilitates verifying message contents and
touching every word in a message (*note Data touching::).  The
following functions implement those features.

 -- Function: void ncptl_fill_buffer (void *BUFFER, ncptl_int NUMBYTES,
          int VALIDITY)
     Fill a region of memory with known values.  If VALIDITY is `+1', `ncptl_fill_buffer()'
     will fill the first NUMBYTES bytes of BUFFER with a verifiable
     sequence of integers (*note Data touching::).  If VALIDITY is `-1', `ncptl_fill_buffer()'
     will pollute the first NUMBYTES bytes of BUFFER.  Receive buffers
     should be polluted before reception to avoid false negatives
     caused, for example, by an inadvertently dropped message destined
     for a previously validated buffer.

 -- Function: ncptl_int ncptl_verify (void *BUFFER, ncptl_int NUMBYTES)
     Verify the contents of memory filled by `ncptl_fill_buffer()'.
     The function returns the number of erroneous bits.  `ncptl_verify()'
     is used to implement CONCEPTUAL's VERIFICATION `WITH VERIFICATION'
     construct (*note Data touching::).

 -- Function: void ncptl_touch_data (void *BUFFER, ncptl_int NUMBYTES)
     Touch every byte in a given buffer.  `ncptl_touch_data()' is used
     to implement the `WITH DATA TOUCHING' construct described in *note
     Data touching::.

   The following function, `ncptl_touch_memory()', does not actually
manipulate message buffers.  It is included in this section because of
its similarity to `ncptl_touch_data()'.  `ncptl_touch_data()' touches
message buffers to implement the `WITH DATA TOUCHING' construct; `ncptl_touch_memory()'
touches a hidden memory region to implement the `TOUCHES' statement.

 -- Function: void ncptl_touch_memory (void *BUFFER, ncptl_int
          BUFFERBYTES, ncptl_int WORDBYTES, ncptl_int FIRSTBYTE,
          ncptl_int NUMACCESSES, ncptl_int BYTESTRIDE)
     Walk a memory region BUFFER of size BUFFERBYTES bytes.  Each
     "word" to touch contains WORDBYTES bytes.  FIRSTBYTE indicates the
     byte index into BUFFER from which to start touching.  The function
     will read and write NUMACCESSES "words" with stride BYTESTRIDE
     bytes.  For example, `ncptl_touch_memory (mybuffer, 1048576, 64,
     192, 10000, 4096)' will read and write (but otherwise do nothing
     with) the 64 bytes that lie 192 bytes into a 1MB memory region,
     then the 64 bytes starting at offset 4288, then the 64 bytes
     starting at 192+4096*2, then at 192+4096*3, then at 192+4096*4,
     and so forth up to 192+4096*10000, wrapping around the 1MB region
     as necessary.

     A BYTESTRIDE of `NCPTL_INT_MIN' implies a random stride.

     As an important special case, if FIRSTBYTE is `-1', then `ncptl_touch_memory()'
     will touch one or more message buffers (cf. `ncptl_malloc_message()'
     in *note Memory-allocation functions::) instead of the given
     BUFFER.  In that case, BUFFERBYTES stores the buffer number (a
     nonnegative number).  If BUFFERBYTES is `-1', however, then _all_
     message buffers are touched.  Note that when FIRSTBYTE is `-1', all
     parameters to `ncptl_touch_memory()' other than BUFFERBYTES are
     ignored.

     `ncptl_touch_memory()' is intended to to be used to implement the `TOUCHES'
     statement (*note Touching memory::).


File: conceptual.info,  Node: Time-related functions,  Next: Log-file functions,  Prev: Message-buffer manipulation functions,  Up: Run-time library functions

6.3.5 Time-related functions
----------------------------

An essential component of any benchmarking system is an accurate timer.
CONCEPTUAL's `ncptl_time()' function selects from a variety of timers
at configuration time, first favoring lower-overhead cycle-accurate
timers, then higher-overhead cycle-accurate, and finally
non-cycle-accurate timers.  `ncptl_init()' measures the actual timer
overhead and resolution and `ncptl_log_write_prologue()' writes this
information to the log file.  Furthermore, the `validatetimer' program
(*note Validating the coNCePTuaL timer::) can be used to verify that
the timer used by `ncptl_init()' truly does correspond to wall-clock
time.

   The CONCEPTUAL language provides a few time-related functions.  These
are supported by the functions described below.

 -- Function: uint64_t ncptl_time (void)
     Return the time in microseconds.  The timer ticks even when the
     program is not currently scheduled.  No assumptions can be made
     about the relation of the value returned to the time of day; `ncptl_time()'
     is intended to be used strictly for computing elapsed time.  The
     timer's resolution and accuracy are logged to the log file by `ncptl_log_write_prologue()'
     (more precisely, by the internal `log_write_prologue_timer()'
     function, which is called by `ncptl_log_write_prologue()').  Note
     that `ncptl_time()' always returns a 64-bit unsigned value,
     regardless of how `ncptl_int' is declared.

     The CONCEPTUAL `configure' script (*note configure::) searches for
     a number of high-resolution timers and selects the best timer
     mechanism from among the ones available.  The selection criteria
     is as follows:

       1. If `./configure ' was passed `--with-gettimeofday' (*note
          configure::) then `ncptl_time()' uses `gettimeofday()' as its
          timer mechanism.

       2. If `./configure ' was passed `--with-mpi-wtime' (*note
          configure::) then `ncptl_time()' uses `MPI_Wtime()' as its
          timer mechanism.

       3. If `./configure ' recognizes the CPU architecture, knows how
          to instruct the C compiler to insert inline assembly code,
          and can determine the number of clock cycles per second, then `ncptl_time()'
          reads the timer using inline assembly code.  If the cycle
          counter is likely to wrap around during a moderately long
          benchmark (i.e., because the cycle counter is a 32-bit
          register), `ncptl_time()' augments the inline assembly code
          with calls to `gettimeofday()' in an attempt to produce
          accurate timings that don't suffer from clock wraparound.

       4. If the Linux `get_cycles()' function is available and `./configure
          ' can determine the number of clock cycles per second then `ncptl_time()'
          uses `get_cycles()' to measure execution time.

       5. If the PAPI library is available, `ncptl_time()' becomes a
          call to PAPI's `PAPI_get_real_usec()' function.

       6. If the System V `clock_gettime()' function is available and
          the `CLOCK_SGI_CYCLE' macro is defined, `ncptl_time()'
          invokes `clock_gettime()' with the `CLOCK_SGI_CYCLE'
          argument.  If `CLOCK_SGI_CYCLE' is not defined but `CLOCK_REALTIME'
          is, then `ncptl_time()' invokes `clock_gettime()' with the `CLOCK_REALTIME'
          argument.

       7. Intel's (now obsolete) supercomputers provide a `dclock()'
          function for reading the time.  `ncptl_time()' makes use of `dclock()'
          if it's available.

       8. Microsoft Windows provides functions for reading a
          high-resolution timer (`QueryPerformanceCounter()') and for
          determining the number of ticks per second that the timer
          measures (`QueryPerformanceFrequency()').  If those functions
          are available, `ncptl_time()' uses them.

       9. As a last resort,  `ncptl_time()' uses `gettimeofday()' to
          measure execution time.

     Furthermore, CONCEPTUAL makes use of the Timers (HPET)
     High-Precision Event Timers (HPET) device if and only if all of
     the following conditions hold at run time:

        * neither `--with-gettimeofday', `--with-mpi-wtime', nor `--disable-hpet'
          was specified to `./configure '

        * `/dev/hpet'--or an alternative device specified at
          configuration time with `--enable-hpet'--exists, is readable,
          and can be memory-mapped into user space

        * the HPET device's main counter is a 64-bit value, not a
          32-bit value

        * the period of the HPET counter is within the ranges required
          by the HPET specification, i.e., between 0 and 100 nanoseconds

     Failing any of those conditions, CONCEPTUAL falls back to the timer
     selected at configuration time.  See the HPET specification
     (http://www.intel.com/hardwaredesign/hpetspec.htm) for more
     information on HPET.

 -- Function: void ncptl_set_flag_after_usecs (volatile int *FLAG,
          uint64_t DELAY)
     `ncptl_set_flag_after_usecs()' uses the operating system's
     interval timer to asynchronously set a variable to `1' after a
     given number of microseconds.  This function is intended to be
     used to support the ``FOR' TIME' construct (*note Timed loops::).
     Note that DELAY is a 64-bit unsigned value, regardless of how `ncptl_int'
     is declared.

     `ncptl_set_flag_after_usecs()' is implemented in terms of the `setitimer()'
     function and issues a run-time error if the `setitimer()' function
     is not available.

 -- Function: void ncptl_udelay (uint64_t DELAY, int SPIN0BLOCK1)
     If SPIN0BLOCK1 is `0', `ncptl_udelay()' spins for DELAY
     microseconds (i.e., using the CPU).  If SPIN0BLOCK1 is `1', `ncptl_udelay()'
     sleeps for DELAY microseconds (i.e., relinquishing the CPU).  Note
     that DELAY is a 64-bit unsigned value, regardless of how `ncptl_int'
     is declared.  `ncptl_udelay()' is intended to be used to support
     the CONCEPTUAL language's `SLEEPS' and `COMPUTES' statements
     (*note Delaying execution::).

     When SPIN0BLOCK1 is `0', `ncptl_udelay()' uses `ncptl_time()' to
     determine when DELAY microseconds have elapsed.  Unless `ncptl_time()'
     is known to utilize an extremely low-overhead timer, `ncptl_udelay()'
     intersperses calls to `ncptl_time()' with writes to a dummy
     variable.  When SPIN0BLOCK1 is `0', `ncptl_udelay()' invokes `nanosleep()'
     to introduce delays.  `ncptl_udelay()' issues a run-time error if
     the `nanosleep()' function is not available.


File: conceptual.info,  Node: Log-file functions,  Next: Random-task functions,  Prev: Time-related functions,  Up: Run-time library functions

6.3.6 Log-file functions
------------------------

Benchmarking has limited value without a proper record of the
performance results.  The CONCEPTUAL run-time library provides functions
for writing data to log files.  It takes care of much of the work
needed to calculate statistics on data columns and to log a thorough
experimental setup to every log file.

   The library treats a log file as a collection of tables of data.
Each table contains a number of rows, one per dynamic invocation of the `LOGS'
statement (*note Writing to a log file::).  Each row contains a number
of columns, one per aggregate expression (*note Aggregate
expressions::) expressed statically in a CONCEPTUAL program.(1)
Log-file functions should be called only if the CONCEPTUAL source code
accesses a log file (*note Writing to a log file::).

 -- Function: void ncptl_log_add_comment (const char *KEY, const char
          *VALUE)
     `ncptl_log_add_comment()' makes it possible for a backend to add
     backend-specific <KEY:VALUE> pairs to the set of prologue or
     epilogue comments that get written to a log file (*note Log-file
     format::).  `ncptl_log_add_comment()' can be called repeatedly.
     All calls that precede `ncptl_log_open()' are included in the
     log-file prologue.  All calls that follow `ncptl_log_open()' are
     included in the log-file epilogue.  Note that `ncptl_log_add_comment()'
     makes a copy of KEY and VALUE, so these need not be heap-allocated.

 -- Function: NCPTL_LOG_FILE_STATE * ncptl_log_open (char *TEMPLATE,
          ncptl_int PROCESSOR)
     Given a filename template containing a `%d' placeholder and a
     processor number (i.e., the process's physical rank in the
     computation), `ncptl_log_open()' creates and opens a log file
     named by the template with `%d' replaced by PROCESSOR.  For
     example, if TEMPLATE is `/home/me/myprog-%d.log' and PROCESSOR is
     `3', the resulting filename will be `/home/me/myprog-3.log'.  `ncptl_log_open()'
     must be called before any of the other `ncptl_log_SOMETHING()'
     functions--except for `ncptl_log_add_comment()', which should be
     called before `ncptl_log_open()'.  `ncptl_log_open()' returns a
     pointer to an opaque `NCPTL_LOG_FILE_STATE' value; the backend
     will need to pass this pointer to nearly all of the other log-file
     functions described in this section.

     There are three special cases for TEMPLATE.  First, if TEMPLATE
     points to an empty string, all log-file output is sent to the null
     device (i.e., `/dev/null' on Unix and Unix-like operating
     systems).  Second, if TEMPLATE is a single dash (`-'), all
     log-file output is sent to the standard output device.  Third, if
     TEMPLATE is a single dollar sign (`$'), all log-file output is
     buffered in a library-internal string.  The string can be
     retrieved using `ncptl_log_get_contents()'.

 -- Function: char * ncptl_log_generate_uuid (void)
     Return a random string of hexadecimal digits formatted as
     "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX" (36 bytes plus a `NULL'
     byte) to pass to `ncptl_log_write_prologue()'.  The caller should `ncptl_free()'
     the string when it is no longer needed (generally, as soon as `ncptl_log_write_prologue()'
     returns).

 -- Function: void ncptl_log_write_prologue (NCPTL_LOG_FILE_STATE
          *LOGSTATE, char *PROGNAME, char *UUID, char *BACKEND_NAME,
          char *BACKEND_DESC, ncptl_int NUMTASKS, NCPTL_CMDLINE
          *ARGLIST, int NUMARGS, char **SOURCECODE)
     `ncptl_log_write_prologue()' standardizes the prologue with which
     all log files begin.  PROGNAME is the name of the program
     executable (`argv[0]' in C).  UUID is a value returned by `ncptl_log_generate_uuid()'.
     Note that every process in a program must pass the same value of
     UUID to `ncptl_log_write_prologue()'.  BACKEND_NAME is the name of
     the backend in `LANGUAGE_LIBRARY' format (e.g., `java_rmi').
     BACKEND_DESC is a brief description of the backend (e.g., `Java +
     RMI').  NUMTASKS is the total number of tasks in the program.
     ARGLIST is the list of arguments passed to `ncptl_parse_command_line()'
     and NUMARGS is the number of entries in that list.  SOURCECODE is
     the complete CONCEPTUAL source code stored as a `NULL'-terminated
     list of `NULL'-terminated strings.

 -- Function: char * ncptl_log_lookup_string (NCPTL_LOG_FILE_STATE
          *LOGSTATE, char *KEY)
     `ncptl_log_write_prologue()' stores every <KEY:VALUE> comment it
     writes into an in-memory database.  `ncptl_log_lookup_string()'
     searches the comment database for a key and returns the
     corresponding value.  The function returns the empty string if the
     key is not found in the database.  In either case, the caller
     should not deallocate the result.  `ncptl_log_lookup_string()' is
     intended to be used to implement CONCEPTUAL's `THE VALUE OF'
     construct (*note Utilizing log-file comments::).

 -- Function: void ncptl_log_write (NCPTL_LOG_FILE_STATE *LOGSTATE, int
          LOGCOLUMN, char *DESCRIPTION, LOG_AGGREGATE AGGREGATE, double
          VALUE)
     Push value VALUE onto column LOGCOLUMN of the current table.  Gaps
     between columns are automatically elided.  DESCRIPTION is used as
     the column header for column LOGCOLUMN.  Acceptable values for
     AGGREGATE are defined in *note Representing aggregate functions::.

 -- Function: void ncptl_log_compute_aggregates (NCPTL_LOG_FILE_STATE
          *LOGSTATE)
     `ncptl_log_compute_aggregates()' implements the AGGREGATES
     `COMPUTES AGGREGATES' construct described in *note Computing
     aggregates::.  When `ncptl_log_compute_aggregates()' is invoked,
     the CONCEPTUAL run-time library uses the aggregate function
     specified by `ncptl_log_write()' to aggregate all of the data that
     accumulated in each column since the last invocation of `ncptl_log_compute_aggregates()'.
     Note that `ncptl_log_compute_aggregates()' is called implicitly by `ncptl_log_commit_data()'.

 -- Function: void ncptl_log_commit_data (NCPTL_LOG_FILE_STATE
          *LOGSTATE)
     The CONCEPTUAL run-time library keeps the current data table in
     memory and doesn't write anything to the log file until `ncptl_log_commit_data()'
     is called, at which point the run-time library writes all
     accumulated data to the log file and begins a new data table.
     Note that `ncptl_log_commit_data()' is called implicitly by `ncptl_log_close()'.
     Furthermore, a backend should call `ncptl_log_commit_data()' when
     beginning execution of a new statement in a CONCEPTUAL program.
     For instance, the `codegen_c_generic.py' backend invokes `ncptl_log_commit_data()'
     from `code_def_main_newstmt'.

 -- Function: void ncptl_log_write_epilogue (NCPTL_LOG_FILE_STATE
          *LOGSTATE)
     Write a stock set of comments as an epilogue to the log file.

 -- Function: const char * ncptl_log_get_contents (NCPTL_LOG_FILE_STATE
          *LOGSTATE)
     Return the current contents of the log file as a string.  The
     caller must not use the string after the next run-time library
     call that modifies the log file, modify the string, or free the
     string.  The caller should copy the string (e.g., with `ncptl_strdup()')
     if any of those actions are necessary.  If the the log file does
     not support random access (because it goes to the standard-output
     device or the null device), `NULL' is returned.

 -- Function: void ncptl_log_close (NCPTL_LOG_FILE_STATE *LOGSTATE)
     Close the log file.  No `ncptl_log_SOMETHING()' function should be
     called after `ncptl_log_close()' is invoked.

   ---------- Footnotes ----------

   (1) Writing `A HISTOGRAM OF THE' <EXPR> produces two columns, one
for values and one for tallies.


File: conceptual.info,  Node: Random-task functions,  Next: Task-mapping functions,  Prev: Log-file functions,  Up: Run-time library functions

6.3.7 Random-task functions
---------------------------

Randomness appears in various forms in the CONCEPTUAL language, such as
when assigning a task to `A RANDOM PROCESSOR' (*note Reordering task
IDs::) or when let-binding `A RANDOM TASK' or `A RANDOM TASK OTHER
THAN' a given task ID to a variable (*note Binding variables::).  The
following functions are used to select tasks at random.  CONCEPTUAL
currently uses the Mersenne Twister as its random-number generator.
Hence, given the same seed, a CONCEPTUAL program will see the same
random-number sequence on every platform.

 -- Function: int ncptl_seed_random_task (int SEED, ncptl_int PROCID)
     Initialize the random-number generator needed by `ncptl_random_task()'.
     If SEED is zero, `ncptl_seed_random_task()' selects an arbitrary
     seed value.  `ncptl_seed_random_task()' returns the seed that was
     used.  PROCID specifies the (physical) processor ID of the calling
     task and is needed to seed the task-local random-number generators
     used by some of the functions in *note Language-visible
     functions::.

 -- Function: ncptl_int ncptl_random_task (ncptl_int LOWER_BOUND,
          ncptl_int UPPER_BOUND, ncptl_int EXCLUDED)
     Return a randomly selected task number from LOWER_BOUND to
     UPPER_BOUND (both inclusive).  If EXCLUDED is nonnegative then
     that task number will never be selected, even if it's within range.


File: conceptual.info,  Node: Task-mapping functions,  Next: Queue functions,  Prev: Random-task functions,  Up: Run-time library functions

6.3.8 Task-mapping functions
----------------------------

 -- Function: NCPTL_VIRT_PHYS_MAP * ncptl_allocate_task_map (ncptl_int
          NUMTASKS)
     Allocate and initialize an opaque `NCPTL_VIRT_PHYS_MAP' object and
     return a pointer to it.

 -- Function: ncptl_int ncptl_virtual_to_physical (NCPTL_VIRT_PHYS_MAP
          *PROCMAP, ncptl_int VIRTID)
     Given a process map allocated by `ncptl_allocate_task_map()' and a
     (virtual) task ID, return the corresponding (physical) process ID.

 -- Function: ncptl_int ncptl_physical_to_virtual (NCPTL_VIRT_PHYS_MAP
          *PROCMAP, ncptl_int PHYSID)
     Given a process map allocated by `ncptl_allocate_task_map()' and a
     (physical) process ID, return the corresponding (virtual) task ID.

 -- Function: ncptl_int ncptl_assign_processor (ncptl_int VIRTID,
          ncptl_int PHYSID, NCPTL_VIRT_PHYS_MAP *PROCMAP, ncptl_int
          PHYSRANK)
     Assign a (physical) processor ID, PHYSID, to a (virtual) task ID,
     VIRTID given a virtual-to-physical mapping table, PROCMAP.  Return
     a new task ID for the caller's processor given its processor ID,
     PHYSRANK.  `ncptl_assign_processor()' is intended to implement the ASSIGNED
     TO `IS ASSIGNED TO' construct (*note Reordering task IDs::).


File: conceptual.info,  Node: Queue functions,  Next: Unordered-set functions,  Prev: Task-mapping functions,  Up: Run-time library functions

6.3.9 Queue functions
---------------------

Because queues are a widely applicable construct, the run-time library
provides support for queues of arbitrary datatypes.  In the current
implementation, these can more precisely be termed "dynamically growing
lists" than "queues".  However, they may be extended in a future
version of the library to support more queue-like functionality.

 -- Function: NCPTL_QUEUE * ncptl_queue_init (ncptl_int ELTBYTES)
     `ncptl_queue_init()' creates and initializes a dynamically growing
     queue in which each element occupies ELTBYTES bytes of memory.

 -- Function: void * ncptl_queue_allocate (NCPTL_QUEUE *QUEUE)
     Allocate a new data element at the end of queue QUEUE.  The queue
     passed to `ncptl_queue_allocate()' must be one returned by `ncptl_queue_init()'.
     `ncptl_queue_allocate()' returns a pointer to the data element
     allocated.

 -- Function: void * ncptl_queue_push (NCPTL_QUEUE *QUEUE, void
          *ELEMENT)
     Push (via a memory copy) the element pointed to by ELEMENT onto
     the end of queue QUEUE and return a pointer to the copy in the
     queue.  The queue passed to `ncptl_queue_allocate()' must be one
     returned by `ncptl_queue_init()'.  (`ncptl_queue_push()' is
     actually implemented in terms of `ncptl_queue_allocate()'.)

 -- Function: void ncptl_queue_push_all (NCPTL_QUEUE *TARGET_QUEUE,
          NCPTL_QUEUE *SOURCE_QUEUE)
     Push (via a memory copy) all of the elements in SOURCE_QUEUE onto
     the end of TARGET_QUEUE.  A fatal error will occur if the two
     queues were not initialized with the same ELTBYTES argument to `ncptl_queue_init()'.
     `ncptl_queue_push_all()' does not modify SOURCE_QUEUE.

 -- Function: void * ncptl_queue_pop (NCPTL_QUEUE *QUEUE)
     Pop a pointer to the element at the head of queue QUEUE.  If QUEUE
     is empty, return `NULL'.  The pointer returned by `ncptl_queue_pop()'
     is guaranteed to be valid until the next invocation of `ncptl_queue_empty()'.

 -- Function: void * ncptl_queue_pop_tail (NCPTL_QUEUE *QUEUE)
     Pop a pointer to the element at the tail of queue QUEUE.  If QUEUE
     is empty, return `NULL'.  In essence, this lets the caller treat
     the queue as a stack.  The pointer returned by `ncptl_queue_pop_tail()'
     is guaranteed to be valid until the next invocation of `ncptl_queue_empty()', `ncptl_queue_allocate()'
     or `ncptl_queue_push()'.

 -- Function: void * ncptl_queue_contents (NCPTL_QUEUE *QUEUE, int
          COPYELTS)
     Return queue QUEUE as an array of elements.  If `ncptl_queue_contents()'
     is passed `1' for COPYELTS, a new array is allocated using `ncptl_malloc()';
     the queue's internal array is copied to the newly allocated array;
     and, this new array is returned to the caller.  It is the caller's
     responsibility to pass the result to `ncptl_free()' when the array
     is no longer needed.  If `ncptl_queue_contents()' is passed `0' for
     COPYELTS, a pointer to the queue's internal array is returned
     without first copying it.  This pointer should not be passed to `ncptl_free()'
     as it is still needed by QUEUE.

 -- Function: ncptl_int ncptl_queue_length (NCPTL_QUEUE *QUEUE)
     Return the number of elements in queue QUEUE.

 -- Function: void ncptl_queue_empty (NCPTL_QUEUE *QUEUE)
     Empty a queue, freeing the memory that had been allocated for its
     elements.  Queue contents returned by `ncptl_queue_contents()'
     with COPYELTS set to `0' are also invalidated.  The queue itself
     can continue to be used and should be deallocated with `ncptl_free()'
     (*note Memory-allocation functions::) when no longer needed.


File: conceptual.info,  Node: Unordered-set functions,  Next: Language-visible functions,  Prev: Queue functions,  Up: Run-time library functions

6.3.10 Unordered-set functions
------------------------------

Because unordered collections of data are a widely applicable
construct, the run-time library provides support for sets.  A set
contains zero or more keys, each of which must be unique within the
set.  Furthermore, each key can be associated with a data value.  Sets
are currently implemented in the CONCEPTUAL run-time library as hash
tables.

 -- Function: NCPTL_SET * ncptl_set_init (ncptl_int NUMELTS, ncptl_int
          KEYBYTES, ncptl_int VALUEBYTES)
     Allocate and initialize a set object and return a pointer to it.
     Each element in the set maps a KEYBYTES-byte key to a
     VALUEBYTES-byte value.  The NUMELTS parameter is an estimate of
     the maximum number of elements in the set.  `ncptl_set_init()'
     returns a pointer to the set.

 -- Function: void * ncptl_set_find (NCPTL_SET *SET, void *KEY)
     Given a set and a pointer to a key, return a pointer to the
     associated value or `NULL' if the key is not found in the set.

 -- Function: void ncptl_set_insert (NCPTL_SET *SET, void *KEY, void
          *VALUE)
     Insert a key into a set and associate a value with it.  `ncptl_set_insert()'
     copies both KEY and VALUE so stack-allocated keys and values are
     acceptable inputs.  The run-time library aborts with an error
     message if the key is already in the set.

 -- Function: void ncptl_set_walk (NCPTL_SET *SET, void
          (*USERFUNC)(void *, void *))
     Execute function USERFUNC for every <KEY:VALUE> pair in a set.
     USERFUNC must take two `void *' values as input: a pointer to a
     key and a pointer to a value.  The order in which keys and values
     are passed to the function is unspecified.

 -- Function: void ncptl_set_remove (NCPTL_SET *SET, void *KEY)
     Remove a key and its associated value from a set.  The run-time
     library aborts with an error message if the key is not found in the
     set.

 -- Function: void ncptl_set_empty (NCPTL_SET *SET)
     Empty a set, freeing the memory that had been allocated for its
     contents.  The set itself can continue to be used and should be
     deallocated with `ncptl_free()' (*note Memory-allocation
     functions::) when no longer needed.

 -- Function: ncptl_int ncptl_set_length (NCPTL_SET *SET)
     Return the number of <KEY:VALUE> pairs in set SET.


File: conceptual.info,  Node: Language-visible functions,  Next: Finalization functions,  Prev: Unordered-set functions,  Up: Run-time library functions

6.3.11 Language-visible functions
---------------------------------

The CONCEPTUAL language contains a number of built-in functions that
perform various operations on floating-point numbers (used when writing
to a log file or the standard output device) and integers (used at all
other times) and that determine the IDs of neighboring tasks on a
variety of topologies.  Each function occurs in two forms:
`ncptl_func_FUNCTION', which maps `ncptl_int's to `ncptl_int's, and
`ncptl_dfunc_FUNCTION', which maps `double's to `double's.  *Note
Built-in functions::, for additional details about each function's
semantics.

   Although some of the functions described in this section are fairly
simple, including them in the run-time library ensures that each
function returns the same value across different backends and across
different platforms.

* Menu:

* Integer-function descriptions::  Mapping one integer to another
* Floating-point-function descriptions::  Mapping one FP number to another
* Topology-function descriptions::  Locating nearby tasks
* Random-number-function descriptions::  Choosing numbers at random


File: conceptual.info,  Node: Integer-function descriptions,  Next: Floating-point-function descriptions,  Prev: Language-visible functions,  Up: Language-visible functions

Integer functions
.................

 -- Function: ncptl_int ncptl_func_sqrt (ncptl_int NUM)
 -- Function: double ncptl_dfunc_sqrt (double NUM)
     `ncptl_func_sqrt()' returns the unique integer x such that x*x <=
     NUM and (x+1)*(x+1) > NUM.  `ncptl_dfunc_sqrt()' returns the
     square root of NUM in double-precision arithmetic.

 -- Function: ncptl_int ncptl_func_cbrt (ncptl_int NUM)
 -- Function: double ncptl_dfunc_cbrt (double NUM)
     `ncptl_func_cbrt()' returns the unique integer x such that x*x*x <=
     NUM and (x+1)*(x+1)*(x+1) > NUM.  `ncptl_dfunc_cbrt()' returns the
     cube root of NUM in double-precision arithmetic.

 -- Function: ncptl_int ncptl_func_root (ncptl_int ROOT, ncptl_int NUM)
 -- Function: double ncptl_dfunc_root (double ROOT, double NUM)
     Return the ROOTth root of a number NUM.  `ncptl_func_root()'
     returns the largest-in-magnitude integer X with the same sign as
     NUM such that |X^ROOT| <= |NUM|.  Currently, NUM must be
     nonnegative but this may change in a future release of CONCEPTUAL.

 -- Function: ncptl_int ncptl_func_bits (ncptl_int NUM)
 -- Function: double ncptl_dfunc_bits (double NUM)
     Return the minimum number of bits needed to represent a given
     integer.  (NUM is rounded up to the nearest integer in the case of `ncptl_dfunc_bits()'.)

 -- Function: ncptl_int ncptl_func_shift_left (ncptl_int NUM, ncptl_int
          BITS)
 -- Function: double ncptl_dfunc_shift_left (double NUM, double BITS)
     Shift a number to the left by BITS bits.  This corresponds to
     multiplying NUM by 2^bits.  In the case of `ncptl_dfunc_shift_left()',
     NUM and BITS are first converted to `ncptl_int' values.  There are
     no corresponding `ncptl_func_shift_right()' or `ncptl_dfunc_shift_right()'
     functions because shifting right by x is defined to be equivalent
     to shifting left by -x.

 -- Function: ncptl_int ncptl_func_log10 (ncptl_int NUM)
 -- Function: double ncptl_dfunc_log10 (double NUM)
     Return the base-10 logarithm of NUM.  In the case of `ncptl_func_log10()',
     this value is rounded down to the nearest integer.

 -- Function: ncptl_int ncptl_func_factor10 (ncptl_int NUM)
 -- Function: double ncptl_dfunc_factor10 (double NUM)
     Return NUM rounded down to the nearest single-digit factor of a
     power of 10.

 -- Function: ncptl_int ncptl_func_abs (ncptl_int NUM)
 -- Function: double ncptl_dfunc_abs (double NUM)
     Return NUM's absolute value.  In the case of `ncptl_func_log10()',
     this value is rounded down to the nearest integer.

 -- Function: ncptl_int ncptl_func_power (ncptl_int BASE, ncptl_int
          EXPONENT)
 -- Function: double ncptl_dfunc_power (double BASE, double EXPONENT)
     Return BASE raised to the power of EXPONENT.

 -- Function: ncptl_int ncptl_func_modulo (ncptl_int NUMERATOR,
          ncptl_int DENOMINATOR)
 -- Function: double ncptl_dfunc_modulo (double NUMERATOR, double
          DENOMINATOR)
     Return the remainder of dividing NUMERATOR by DENOMINATOR.  The
     result is guaranteed to be a nonnegative integer.  `ncptl_dfunc_modulo()'
     rounds each of NUMERATOR and DENOMINATOR down to the nearest
     integer before dividing and taking the remainder.

 -- Function: ncptl_int ncptl_func_min (ncptl_int COUNT, ...)
 -- Function: double ncptl_dfunc_min (double COUNT, ...)
     Return the minimum of a list of numbers.  The first argument
     specifies the number of remaining arguments and must be a positive
     integer.

 -- Function: ncptl_int ncptl_func_max (ncptl_int COUNT, ...)
 -- Function: double ncptl_dfunc_max (double COUNT, ...)
     Return the maximum of a list of numbers.  The first argument
     specifies the number of remaining arguments and must be a positive
     integer.


File: conceptual.info,  Node: Floating-point-function descriptions,  Next: Topology-function descriptions,  Prev: Integer-function descriptions,  Up: Language-visible functions

Floating-point functions
........................

 -- Function: ncptl_int ncptl_func_floor (ncptl_int NUM)
 -- Function: double ncptl_dfunc_floor (double NUM)
     Return the floor of NUM.  (This is the identity function in the
     case of `ncptl_func_floor()'.)

 -- Function: ncptl_int ncptl_func_ceiling (ncptl_int NUM)
 -- Function: double ncptl_dfunc_ceiling (double NUM)
     Return the ceiling of NUM.  (This is the identity function in the
     case of `ncptl_func_ceiling()'.)

 -- Function: ncptl_int ncptl_func_round (ncptl_int NUM)
 -- Function: double ncptl_dfunc_round (double NUM)
     Return NUM rounded to the nearest integer.  (This is the identity
     function in the case of `ncptl_func_round()'.)


File: conceptual.info,  Node: Topology-function descriptions,  Next: Random-number-function descriptions,  Prev: Floating-point-function descriptions,  Up: Language-visible functions

Topology functions
..................

In the following functions, the `dfunc' versions merely cast their
arguments to `ncptl_int's and call the corresponding `func' versions.

 -- Function: ncptl_int ncptl_func_tree_parent (ncptl_int TASK,
          ncptl_int ARITY)
 -- Function: double ncptl_dfunc_tree_parent (double TASK, double ARITY)
     Return task TASK's parent in an ARITY-ary tree.

 -- Function: ncptl_int ncptl_func_tree_child (ncptl_int TASK,
          ncptl_int CHILD, ncptl_int ARITY)
 -- Function: double ncptl_dfunc_tree_child (double TASK, double CHILD,
          double ARITY)
     Return child CHILD of task TASK in an ARITY-ary tree.

 -- Function: ncptl_int ncptl_func_mesh_coord (ncptl_int vartask,
          ncptl_int COORD, ncptl_int WIDTH, ncptl_int HEIGHT, ncptl_int
          DEPTH)
 -- Function: double ncptl_dfunc_mesh_coord (double vartask, double
          COORD, double WIDTH, double HEIGHT, double DEPTH)
     Return task TASK's x coordinate (COORD=0), y coordinate (COORD=1),
     or z coordinate (COORD=2) on a WIDTH*HEIGHT*DEPTH mesh (or torus).

 -- Function: ncptl_int ncptl_func_mesh_neighbor (ncptl_int WIDTH,
          ncptl_int HEIGHT, ncptl_int DEPTH, ncptl_int XTORUS,
          ncptl_int YTORUS, ncptl_int ZTORUS, ncptl_int TASK, ncptl_int
          XDELTA, ncptl_int YDELTA, ncptl_int ZDELTA)
 -- Function: double ncptl_dfunc_mesh_neighbor (double WIDTH, double
          HEIGHT, double DEPTH, double XTORUS, double YTORUS, double
          ZTORUS, double TASK, double XDELTA, double YDELTA, double
          ZDELTA)
     Return one of task TASK's neighbors--not necessarily an immediate
     neighbor--on a 3-D mesh or torus.  For the following explanation,
     assume that task TASK lies at coordinates (x, y, z) on a
     WIDTH*HEIGHT*DEPTH mesh or torus.  In the mesh case
     (XTORUS=YTORUS=ZTORUS=0), the value returned is the task ID
     corresponding to coordinates (x+XDELTA, y+YDELTA, z+ZDELTA).  In
     the full-torus case (XTORUS=YTORUS=ZTORUS=1), the value returned
     is the task ID corresponding to coordinates ((x+XDELTA) mod WIDTH,
     (y+YDELTA) mod HEIGHT, (z+ZDELTA) mod DEPTH).

   Note that there are no 1-D or 2-D grid functions.  Instead, the
appropriate 3-D function should be used with DEPTH and--in the 1-D
case--HEIGHT set to `1'.

 -- Function: ncptl_int ncptl_func_knomial_parent (ncptl_int TASK,
          ncptl_int ARITY, ncptl_int NUMTASKS)
 -- Function: double ncptl_dfunc_knomial_parent (double TASK, double
          ARITY, double NUMTASKS)
     Return task TASK's parent in an ARITY-nomial tree of NUMTASKS
     tasks.

 -- Function: ncptl_int ncptl_func_knomial_child (ncptl_int TASK,
          ncptl_int CHILD, ncptl_int ARITY, ncptl_int NUMTASKS,
          ncptl_int COUNT_ONLY)
 -- Function: double ncptl_dfunc_knomial_child (double TASK, double
          CHILD, double ARITY, double NUMTASKS, double COUNT_ONLY)
     If COUNT_ONLY is `0', return task TASK's CHILDth child in an
     ARITY-nomial tree of NUMTASKS tasks.  If COUNT_ONLY is `1', return
     the number of children task TASK has in an ARITY-nomial tree of
     NUMTASKS tasks.


File: conceptual.info,  Node: Random-number-function descriptions,  Prev: Topology-function descriptions,  Up: Language-visible functions

Random-number functions
.......................

 -- Function: ncptl_int ncptl_func_random_uniform (ncptl_int
          LOWER_BOUND, ncptl_int UPPER_BOUND)
 -- Function: double ncptl_dfunc_random_uniform (double LOWER_BOUND,
          double UPPER_BOUND)
     Return a number in the interval [LOWER_BOUND, UPPER_BOUND)
     selected at random with a uniform distribution.

 -- Function: ncptl_int ncptl_func_random_gaussian (ncptl_int MEAN,
          ncptl_int STDDEV)
 -- Function: double ncptl_dfunc_random_gaussian (double MEAN, double
          STDDEV)
     Return a number selected at random from a Gaussian distribution
     with mean MEAN and standard deviation STDDEV.

 -- Function: ncptl_int ncptl_func_random_poisson (ncptl_int MEAN)
 -- Function: double ncptl_dfunc_random_poisson (double MEAN)
     Return an integer selected at random from a Poisson distribution
     with mean MEAN and standard deviation sqrt(MEAN).

 -- Function: ncptl_int ncptl_func_random_pareto (ncptl_int SHAPE,
          ncptl_int LOWER_BOUND, ncptl_int UPPER_BOUND)
 -- Function: double ncptl_dfunc_random_pareto (double SHAPE, double
          LOWER_BOUND, double UPPER_BOUND)
     If LOWER_BOUND=UPPER_BOUND, return a value selected at random from
     a Pareto distribution with shape SHAPE and scale LOWER_BOUND.  If
     LOWER_BOUND<>UPPER_BOUND, return a value selected at random from a
     bounded Pareto distribution with shape SHAPE and bounded by the
     range [LOWER_BOUND, UPPER_BOUND].


File: conceptual.info,  Node: Finalization functions,  Prev: Language-visible functions,  Up: Run-time library functions

6.3.12 Finalization functions
-----------------------------

The following function should be called towards the end of the generated
code's execution.

 -- Function: void ncptl_finalize (void)
     Shut down the CONCEPTUAL run-time library.  No run-time library
     functions should be invoked after `ncptl_finalize()'.

 -- Function: void ncptl_fatal (char *FORMAT, ...)
     Output an error message and abort the program.  `ncptl_fatal()'
     takes the same types of arguments as C's `printf()' routine.


File: conceptual.info,  Node: Tips and Tricks,  Next: Troubleshooting,  Prev: Implementation,  Up: Top

7 Tips and Tricks
*****************

The following sections present some ways to make better use of
CONCEPTUAL in terms of producing simpler, more efficient programs or
being able to run on complex computer systems.

* Menu:

* Using out-of-bound task IDs to simplify code::  Exploiting dropped messages
* Proper use of conditionals::  When and when not to use IF...THEN
* Memory efficiency::           Reducing programs' memory usage
* Cross-compilation::           Compiling on one architecture to run on another
* Implicit dynamic-library search paths::  Not needing to set LD_LIBRARY_PATH
* Running without installing::  Compiling right from the build directory
* Reporting configuration information::  Self-describing coNCePTuaL libraries


File: conceptual.info,  Node: Using out-of-bound task IDs to simplify code,  Next: Proper use of conditionals,  Prev: Tips and Tricks,  Up: Tips and Tricks

7.1 Using out-of-bound task IDs to simplify code
================================================

*Note Task descriptions::, mentions a language feature that can
substantially simplify CONCEPTUAL programs: Operations involving
out-of-bound task IDs are silently ignored.  The beauty of this feature
is that it reduces the need for special cases at network boundaries.
Consider, for example, a simple pipeline pattern in which each task in
turn sends a message to the subsequent task:

     ALL TASKS t SEND A 64 DOUBLEWORD MESSAGE TO TASK t+1.

   Because implicit receives are posted before the corresponding sends
(*note Sending::), all tasks except task 0 start by posting a blocking
receive.  (No task is sending to task 0.)  Task 0 is therefore free to
send a message to task 1.  Receipt of that message unblocks task 1, who
then sends a message to task 2, thereby unblocking task 3, and so
forth.  Without needing an explicit special case in the program, task
`num_tasks-1' receives a message from task `num_tasks-2' but does not
attempt to send a message to nonexistent task `num_tasks', thanks to
the rule that communication with nonexistent tasks turns into a no-op
(i.e., is elided from the program).

   As a more complex variation of the same program, consider a wavefront
communication pattern that progresses from the upper-left corner of a
mesh to the lower-right corner.  Such a pattern can be expressed in
just four lines of CONCEPTUAL (receive left, receive up, send right,
send down) by relying on the property that communication with a
nonexistent task is simply not executed:

     TASK MESH_NEIGHBOR(src, xsize, +1, ysize,  0) RECEIVES A
       64 DOUBLEWORD MESSAGE FROM ALL TASKS src THEN
     TASK MESH_NEIGHBOR(src, xsize,  0, ysize, +1) RECEIVES A
       64 DOUBLEWORD MESSAGE FROM ALL TASKS src THEN
     ALL TASKS src SEND A 64 DOUBLEWORD MESSAGE TO
       UNSUSPECTING TASK MESH_NEIGHBOR(src, xsize, +1, ysize,  0) THEN
     ALL TASKS src SEND A 64 DOUBLEWORD MESSAGE TO
       UNSUSPECTING TASK MESH_NEIGHBOR(src, xsize,  0, ysize, +1).

   To understand the preceding program recall that `MESH_NEIGHBOR'
returns `-1' for nonexistent neighbors.  Because `-1' is outside of the
range [0, `num_tasks') communication with a nonexistent neighbor is
ignored.  To help the reader understand the preceding program, we
present a trace of the events it posts as it runs with a 2 by 2
arrangement of tasks:

     [TRACE] phys: 0 | virt: 0 | action: SEND | event: 1 / 2 | lines: 3 - 3
     [TRACE] phys: 1 | virt: 1 | action: RECV | event: 1 / 2 | lines: 1 - 1
     [TRACE] phys: 2 | virt: 2 | action: RECV | event: 1 / 2 | lines: 2 - 2
     [TRACE] phys: 3 | virt: 3 | action: RECV | event: 1 / 2 | lines: 1 - 1

     [TRACE] phys: 0 | virt: 0 | action: SEND | event: 2 / 2 | lines: 4 - 4
     [TRACE] phys: 1 | virt: 1 | action: SEND | event: 2 / 2 | lines: 4 - 4

     [TRACE] phys: 2 | virt: 2 | action: SEND | event: 2 / 2 | lines: 3 - 3

     [TRACE] phys: 3 | virt: 3 | action: RECV | event: 2 / 2 | lines: 2 - 2

   The `c_trace' backend (*note The c_trace backend::) was used to
produce that trace.  To increase clarity, we manually added blank lines
to group concurrent events (i.e., there is no significance to the order
of the `TRACE' lines within each group).  The important thing to notice
is that there are exactly four receives and exactly four sends:

   * Although all tasks are instructed to receive a message from the
     left, only tasks 1 and 3 actually do so;

   * although all tasks are instructed to receive a message from above,
     only tasks 2 and 3 actually do so;

   * although all tasks are instructed to send a message to the right,
     only tasks 0 and 2 actually do so; and,

   * although all tasks are instructed to send a message downwards, only
     tasks 0 and 1 actually do so.

Because communication with nonexistent tasks is elided at program
initialization time there is no run-time cost for such operations--as
evidenced by the `c_trace' output presented above.  Furthermore, there
is no reliance on the backend to drop messages from nonexistent senders
or to nonexistent receivers; it is perfectly safe to utilize no-op'ed
communcation in any CONCEPTUAL program and when using any backend.


File: conceptual.info,  Node: Proper use of conditionals,  Next: Memory efficiency,  Prev: Using out-of-bound task IDs to simplify code,  Up: Tips and Tricks

7.2 Proper use of conditionals
==============================

CONCEPTUAL supports two forms of conditional execution: conditional
expressions (*note Arithmetic expressions::) and conditional statements
(*note Conditional execution::).  From the perspective of code
readability and "thinking in CONCEPTUAL" it is generally preferable to
use restricted identifiers (*note Restricted identifiers::) to select
groups of tasks rather than a loop with a conditional as would be
typical in other programming languages.  For example, consider the
following code in which certain even-numbered tasks each send a message
to the right:

     FOR EACH evtask IN {0, ..., num_tasks-1}
       IF evtask IS EVEN /\ evtask MOD 3 <> 2 THEN
         TASK evtask SENDS A 64 BYTE MESSAGE TO TASK evtask+1

While the preceding control flow is representative of that in other
programming languages, CONCEPTUAL can express the same communication
pattern without needing either a loop or an explicit conditional
statement:

     TASK evtask SUCH THAT evtask IS EVEN /\ evtask MOD 3 <> 2 SENDS A 64
     BYTE MESSAGE TO TASK evtask+1

   One situation in which conditional statements do not have a
convenient analogue is when a program selects among multiple disparate
subprograms based on a command-line parameter:

     func IS "Operation to perform (1=OP1; 2=OP2; 3=OP3)" AND COMES FROM
     "--function" OR "-f" WITH DEFAULT 1.

     ASSERT THAT "the function must be 1, 2, or 3" WITH func>=1 /\ func<=3.

     IF func = 1 THEN {
       Perform operation OP1.
     }
     OTHERWISE IF func = 2 THEN {
       Perform operation OP2.
     }
     OTHERWISE IF func = 3 THEN {
       Perform operation OP3.
     }


File: conceptual.info,  Node: Memory efficiency,  Next: Cross-compilation,  Prev: Proper use of conditionals,  Up: Tips and Tricks

7.3 Memory efficiency
=====================

As described in *note Generated code::, the `c_generic' backend (and
therefore all derived backends) generates programs that run by
executing a sequence of events in an event list.  While this form of
program execution makes it possible to hoist a significant amount of
computation out of the timing loop, it does imply that a program's
memory requirements are proportional to the number of statements that
the program executes.

   CONCEPTUAL's memory usage can be reduced by taking advantage of
repeat counts within statements that support such a construct.  The
language's <SEND_STMT> (*note Sending::), <RECEIVE_STMT> (*note
Receiving::), and <TOUCH_STMT> (*note Touching memory::) are all
examples of statements that accept repeat counts.  For other statements
and for groups of statements that repeat, the `FOR'...`REPETITIONS'
statement produces a single `EV_REPEAT' event followed by a single
instance of the events in the loop body.  This technique is valid
because CONCEPTUAL knows a priori that every iteration is identical to
every other iteration.  In contrast, the more general `FOR EACH'
statement can induce different behavior each iteration based on the
value of the loop variable so programs must conservatively instantiate
the events in the loop body for every iteration.  Consider the following
examples:

_Least efficient:_
     `FOR EACH i IN {1, ..., 1000} TASK 0 TOUCHES A 1 WORD MEMORY
     REGION'
     (1000 `EV_TOUCH' events on task 0)

_More efficient:_
     `FOR 1000 REPETITIONS TASK 0 TOUCHES A 1 WORD MEMORY REGION'
     (an `EV_REPEAT' event and an `EV_TOUCH' event on task 0)

_Most efficient:_
     `TASK 0 TOUCHES A 1 WORD MEMORY REGION 1000 TIMES'
     (one `EV_TOUCH' event on task 0)


_Least efficient:_
     `FOR EACH i IN {1, ..., 1000} TASK 0 SENDS A 32 KILOBYTE MESSAGE
     TO TASK 1'
     (1000 `EV_SEND' events on task 0 and 1000 `EV_RECV' events on
     task 1)

_More efficient:_
     `FOR 1000 REPETITIONS TASK 0 SENDS A 32 KILOBYTE MESSAGE TO TASK
     1'
     (an `EV_REPEAT' event and an `EV_SEND' event on task 0 plus an `EV_REPEAT'
     event and an `EV_RECV' event on task 1)

_Most efficient:_
     `TASK 0 SENDS 1000 32 KILOBYTE MESSAGES TO TASK 1'
     (currently the same as the above although a future release of
     CONCEPTUAL may reduce this to a single `EV_SEND' event on task 0
     and a single `EV_RECV' event on task 1)


File: conceptual.info,  Node: Cross-compilation,  Next: Implicit dynamic-library search paths,  Prev: Memory efficiency,  Up: Tips and Tricks

7.4 Cross-compilation
=====================

Some experimental architectures lack native compilers and therefore
require programs to be compiled on an architecturally distinct
front-end machine.  CONCEPTUAL can be configured to support such an
arrangement.  As an example, we follow how CONCEPTUAL was recently
configured to run on a Cray/SNL Red Storm prototype.  The Red Storm
prototype requires programs to be cross-compiled from a compile server
then launched from an execution server to run on the compute nodes.
The CPUs in all three node types use the x86-64 architecture but the
compile server and execution server run Linux while the compute nodes
run the lightweight Catamount kernel.  Cross-compilation is necessary
to prevent the `./configure ' script that runs on the compile server
from attempting to execute small programs to test run-time
features--these would be guaranteed to fail.

   `./configure ' (*note configure::) enters cross-compilation mode if
the build system--specified with `--build'--has a different CPU, comes
from a different vendor, or runs a different operating system from the
execution system--specified with `--host'.  The `config.guess' script
outputs the build-system type in the form CPU-VENDOR-OPERATING SYSTEM:

     % ./config.guess
     x86_64-unknown-linux-gnu

(That is, the CPU architecture is `x86_64'; the computer vendor is
`unknown'; and, the operating system is `linux-gnu'.)

   As a special case of cross-compilation, if the build system and
execution system utilize the same CPU and operating system(1)  (but
presumably differ in terms of other feature), `./configure ' provides a `--with-cross-compilation'
option to force a cross-compile.  The alternative is to modify one of
the build-system name components; best is to modify the vendor
component as that's used solely for informational purposes.  For our Red
Storm configuration (which predated the `--with-cross-compilation'
option) we renamed VENDOR from `unknown' to `cray'.

   Because `configure' assumes it cannot execute small test programs on
the execution system, it is unable to determine valid memory-buffer
alignments.  Consequently, the `--with-alignment' option must also be
passed to `configure' to specify explicitly the minimum number of bytes
at which data must be aligned.  (If not specified, the minimum
alignment defaults to `8'.)  We know a priori that the x86-64
architecture can support byte-aligned data.  Hence, we specify `--with-alignment=1'.

   A command line like the following was used to configure CONCEPTUAL
for the Red Storm prototype:

     % ./configure --build=x86_64-unknown-linux-gnu --host=x86_64-cray-linux-gnu
         --with-alignment=1 CC=mpicc

   Once CONCEPTUAL is configured to cross-compile, there is nothing
special about performing the compilation itself.  The `make' command
runs unmodified from its description in *note make::.

   Running `make check' can be tricky because it involves both
compilation and execution.  As stated previously, these cannot be
performed on the same servers in the Red Storm prototype.  The solution
is first to run `make check' on the compile server.  This compiles all
of the CONCEPTUAL regression tests--and unsuccessfully attempts to run
them.  Then, when `make check' is run on the execution server it does
not need to compile any of the tests (which it can't do successfully,
anyway) but can simply run each of them.

   One catch is that the Red Storm execution server cannot directly run
compute-node programs.  Rather, it needs to spawn a job launcher (`yod')
for each test program.  The mechanism for doing this is the `TESTS_ENVIRONMENT'
variable, which check `make check' prepends to every command it
executes.  We were therefore able to regression-test the CONCEPTUAL
run-time library on the Storm Red Storm prototype with the following
command:

     % make TESTS_ENVIRONMENT="yod -list 4" check

   If the system for which you're cross-compiling is unable to run Python
or unable to build the interpreter-based backends, you might consider
building CONCEPTUAL twice--cross-compiled for the target system and
compiled regularly for the front-end system.  The `--prefix' option to `configure'
(*note configure::) specifies the top-level directory for the
CONCEPTUAL installation.

   ---------- Footnotes ----------

   (1) As long as the host and build operating systems have moderately
similar interfaces (e.g., both are Unix-like) and the same CPU
architecture (e.g., both are x86-64 variants), `--with-cross-compilation'
should be applicable.


File: conceptual.info,  Node: Implicit dynamic-library search paths,  Next: Running without installing,  Prev: Cross-compilation,  Up: Tips and Tricks

7.5 Implicit dynamic-library search paths
=========================================

By default, CONCEPTUAL installs both a static and dynamic library with
the dynamic library taking precedence (at least on most Unix and
Unix-like operating systems).  While dynamic libraries offer a number
of benefits--such as not requiring applications to be relinked every
time a library is upgraded--one inconvenience is the need to set the `LD_LIBRARY_PATH'
environment variable to point to the CONCEPTUAL library directory if
the CONCEPTUAL run-time library is not installed in a standard location
(e.g., `/usr/lib').

   An alternative to setting `LD_LIBRARY_PATH' is to specify the target
library directory at configuration time via the `LDFLAGS' variable and
let the linker embed that directory into the CONCEPTUAL run-time
library's dynamic search path.  Many linkers accept a `-rpath' option
for exactly that purpose.  With the GNU C compiler and linker the
appropriate option is `LDFLAGS="-Wl,-rpath,DIRECTORY"' (e.g.,
`LDFLAGS="-Wl,-rpath,/usr/local/ncptl/lib"').  Other compilers may have
analogous mechanisms for passing flags directly to the linker.


File: conceptual.info,  Node: Running without installing,  Next: Reporting configuration information,  Prev: Implicit dynamic-library search paths,  Up: Tips and Tricks

7.6 Running without installing
==============================

You can compile CONCEPTUAL programs without having first to do a `make install'
by using the same mechanism as was discussed in *note Implicit
dynamic-library search paths::.

   First, Libtool builds the CONCEPTUAL run-time library in the `.libs'
subdirectory.  Hence, you should add `LDFLAGS="-L`pwd`/.libs
-Wl,-rpath,`pwd`/.libs"' to the `./configure ' command line (*note
configure::) to point both the static and dynamic linkers to the
CONCEPTUAL build directory.

   Second, CONCEPTUAL-generated C code specifies `#include
<ncptl/ncptl.h>'.  To ensure that the generated code can find `ncptl.h'
you should add `CPPFLAGS="-I`pwd`"' to the `./configure ' command line
to point the C compiler to the CONCEPTUAL build directory.  Then,
create a symbolic link from the CONCEPTUAL build directory to an
`ncptl' directory by running `ln -s `pwd` ncptl' from the build
directory.

   After running `./configure ' and `make', you can compile CONCEPTUAL
programs by invoking the compiler as `./ncptl.py' instead of the usual `ncptl'.


File: conceptual.info,  Node: Reporting configuration information,  Prev: Running without installing,  Up: Tips and Tricks

7.7 Reporting configuration information
=======================================

On platforms that support it, the CONCEPTUAL run-time library is also an
executable program that can be run from the command line.  Executing
the library outputs to the standard output device a complete log-file
prologue and epilogue but no data.(1)  This feature makes it quite
convenient to determine all of the configuration options, compiler
features, etc. that were used to build the run-time library.

   ---------- Footnotes ----------

   (1) This is the same information produced by `make empty.log' (*note
make::).


File: conceptual.info,  Node: Troubleshooting,  Next: Reserved Words,  Prev: Tips and Tricks,  Up: Top

8 Troubleshooting
*****************

In any complex system, things are bound to go wrong.  The following
sections present solutions to various problems that have been
encountered when building CONCEPTUAL and running CONCEPTUAL programs.

* Menu:

* Problems with configure::     What to do when configure fails
* Problems with make::          What to do when make fails
* Problems running::            What to do when a generated program fails
* When all else fails::         Contacting the coNCePTuaL developers


File: conceptual.info,  Node: Problems with configure,  Next: Problems with make,  Prev: Troubleshooting,  Up: Troubleshooting

8.1 Problems with configure
===========================

For typical CONCEPTUAL usage, the most important function of the `configure'
script is to prepare the system to build the CONCEPTUAL run-time
library.  CONCEPTUAL's functionality is severely restricted without
that library.  This section provides information to help ensure that
configuration succeeds.

* Menu:

* Interpreting configure warnings::  General problem-solving instructions
* PRId64 is not a valid printf conversion specifier::  A common problem on BSD
* present but cannot be compiled::  Warning messages involving header files
* Checking maximum line length is slow::  A pathologically slow configure test
* configure is slow::           All configure tests are pathologically slow
* Problems with ``C compiler used for Python extension modules''::  Can't link
* Manual configuration::        Bypassing configure entirely


File: conceptual.info,  Node: Interpreting configure warnings,  Next: PRId64 is not a valid printf conversion specifier,  Prev: Problems with configure,  Up: Problems with configure

8.1.1 Interpreting configure warnings
-------------------------------------

The `configure' script performs a large number of tests to ensure that
CONCEPTUAL will compile properly and function as expected.  In
particular, any missing or improperly functioning feature upon which
the C run-time library relies causes `./configure ' to issue a `not
building the C run-time library' warning.  Without its run-time
library, CONCEPTUAL's functionality is severely limited so it's worth
every effort to get `./configure ' to build that.

   Like all Autoconf scripts, `configure' logs detailed information to
a `config.log' file.  As a general diagnostic technique one should
search for puzzling output in `config.log' and examine the surrounding
context.  For instance, on one particular system, `./configure ' output
`no' following `checking if we can run a trivial program linked with
"-lrt -lm -lpopt "' and then refused to build the run-time library.
The following relevant lines appeared in `config.log':

     configure:12845: checking if we can run a trivial program linked with "-lrt
     -lm -lpopt "
     configure:12862: /usr/local/bin/gcc  -o conftest -g -O2   conftest.c -lrt
     -lm -lpopt  >&5
     configure:12865: $? = 0
     configure:12867: ./conftest
     ld.so.1: ./conftest: fatal: libpopt.so.0: open failed: No such file or
     directory
     ./configure: line 1:  5264 Killed                  ./conftest$ac_exeext
     configure:12870: $? = 137
     configure: program exited with status 137
     configure: failed program was:
     #line 12851 "configure"
     #include "confdefs.h"

     int
     main (int argc, char *argv[])
     {
       return 0;
     }
     configure:12879: result: no

   Note the error message from `ld.so.1' about `libpopt.so.0' not being
found.  Further investigation revealed that although
`/usr/local/bin/gcc' knew to look in `/usr/local/lib/' for shared
libraries, that directory was not in the search path utilized by
`ld.so.1'.  Consequently, it couldn't find
`/usr/local/lib/libpopt.so.0'.  The solution in this case was to add
`/usr/local/lib/' to the `LD_LIBRARY_PATH' environment variable before
running `./configure '.

   In general, `config.log' should be the first place to look when
trying to interpret warnings issued by `./configure '.  Furthermore,
note that certain command-line options to `./configure ' (*note
configure::) may help bypass problematic operations that the script
stumbles over.


File: conceptual.info,  Node: PRId64 is not a valid printf conversion specifier,  Next: present but cannot be compiled,  Prev: Interpreting configure warnings,  Up: Problems with configure

8.1.2 `PRId64 is not a valid printf conversion specifier'
---------------------------------------------------------

The following configuration warning was encountered on various BSD Unix
systems (OpenBSD 3.4 and FreeBSD 4.10-BETA, both IA-32) and inhibited
the building of the CONCEPTUAL run-time library:

     PRId64 is not a valid printf conversion specifier for values of type int64_t

   The `config.log' file indicated the source of the problem was a
`syntax error before `PRId64'' that was reported when compiling a
sample program.  A brief search revealed that the `PRId64' macro is not
defined in any of the standard C header files on the systems in
question.  The solution turned out to be to configure with `./configure
--with-printf-format='"lld"'' to instruct the C compiler to use `printf()'
format strings such as `%lld' when outputting 64-bit signed integers.
The extra pair of double quotes is required because the conversion
specifier is used in constructs like the following:

     printf ("The number is %10" CONVERSION-SPECIFIER "!\n", num);

Most--but apparently not all--C compilers define the `PRId64' macro
("`PRI'nt signed `d'ecimal number of length `64' bits") in one the
standard header files.  Typical values of `PRId64' include the strings
`"lld"' and `"ld"'.


File: conceptual.info,  Node: present but cannot be compiled,  Next: Checking maximum line length is slow,  Prev: PRId64 is not a valid printf conversion specifier,  Up: Problems with configure

8.1.3 Header is `present but cannot be compiled'
------------------------------------------------

On some platforms `./configure ' may output one or more warnings of the
following form:

     WARNING: FILENAME.h: present but cannot be compiled
     WARNING: FILENAME.h:     check for missing prerequisite headers?
     WARNING: FILENAME.h: see the Autoconf documentation
     WARNING: FILENAME.h:     section "Present But Cannot Be Compiled"
     WARNING: FILENAME.h: proceeding with the preprocessor's result
     WARNING: FILENAME.h: in the future, the compiler will take precedence
     WARNING:     ## ----------------------------- ##
     WARNING:     ## Report this to pakin@lanl.gov ##
     WARNING:     ## ----------------------------- ##

   Typically, such warnings indicate that the header file in question
was written for one compiler but a different compiler is being used to
build CONCEPTUAL.  Unless the header file in question poses problems
during the run of `make', the `present but cannot be compiled' warnings
can be ignored and there is no need to report the compiler-preprocessor
mismatch to the e-mail address shown.


File: conceptual.info,  Node: Checking maximum line length is slow,  Next: configure is slow,  Prev: present but cannot be compiled,  Up: Problems with configure

8.1.4 Slow `checking the maximum length of command line arguments...'
---------------------------------------------------------------------

Recent versions of Libtool need to know the maximum supported
command-line length.  Normally, `configure' determines this value by
invoking a test script with successively longer command lines until
such an invocation fails.  On most platforms, the maximum command-line
length is determined almost instantaneously.  However, on one test
system, a 600MHz x86 running the original--not GNU--Bourne shell under
Solaris, `./configure ' was stuck `checking the maximum length of
command line arguments...' for approximately 45 _minutes_.

   Inspecting the `configure' script revealed that the result of
executing the length-checking code in `configure' is an assignment to
the `lt_cv_sys_max_cmd_len' shell variable.  Consequently, running `./configure
lt_cv_sys_max_cmd_len=8192' (or some other conservative estimate of the
maximum command-line length) caused `./configure ' to skip the unduly
slow length-checking test and use the given value instead.


File: conceptual.info,  Node: configure is slow,  Next: Problems with ``C compiler used for Python extension modules'',  Prev: Checking maximum line length is slow,  Up: Problems with configure

8.1.5 `configure' is slow
-------------------------

On a few systems, `./configure ' has been observed to take an extremely
long time to run.  A common source of the problem is a slow filesystem.
During the course of its execution the `configure' script creates and
compiles a large number of small files.  If the current directory
resides in a filesystem that exhibits poor small-file performance, then
this may explain why `./configure ' runs slowly.  Try to configure
CONCEPTUAL from a local filesystem (e.g., `/tmp') and see if it runs
faster.

   A second source of poor CONCEPTUAL configuration speed regards poor
implementations of the Bourne shell.  One test system, a 1.9GHz PowerPC
running the original--not GNU--Bourne shell under AIX, took several
_hours_ to run `./configure ' to completion.  Fortunately, the system
adminstrator had installed the GNU Bourne Again shell (`bash'), which
does not exhibit the same poor performance as the default Bourne shell.  `./configure
' can be instructed to use `bash'--or any Bourne-compatible shell--by
setting the `CONFIG_SHELL' environment variable:

     env CONFIG_SHELL=/usr/local/bin/bash ./configure

   The preceding command reduced configuration time from over two hours
to under two minutes.


File: conceptual.info,  Node: Problems with ``C compiler used for Python extension modules'',  Next: Manual configuration,  Prev: configure is slow,  Up: Problems with configure

8.1.6 Problems with `C compiler used for Python extension modules'
------------------------------------------------------------------

The following message from `configure' is not uncommon:

      * Not building the Python interface to the coNCePTuaL run-time
        library because the C compiler used for Python extension modules
        (gcc -pthread) can't link against the output of gcc

Without the Python interface, none of the Python-based backends can be
built, either:

      * Not installing the coNCePTuaL interpreter because it depends upon
        the Python interface to the coNCePTuaL run-time library
      * Not installing the statistics backend because it depends upon the
        coNCePTuaL interpreter
      * Not installing the PICL backend because it depends upon the
        coNCePTuaL interpreter
      * Not installing the Paraver backend because it depends upon the
        coNCePTuaL interpreter
      * Not installing the LaTeX visualization backend because it depends
        upon the coNCePTuaL interpreter

   Note that CONCEPTUAL is still quite usable without the Python-based
backends; the C+MPI backend (*note The c_mpi backend::), for example,
does not rely on Python.

   A typical cause of the `can't link' message is that the `configure'
script is unable to locate the Python development files that are needed
to build a Python module.  Most Python installations exclude the
development files by default, requiring that they be installed
separately.  In some Linux distributions these files are provided by a
package with a name like `python-dev'.  A key file to look for is `Python.h'.
If `./configure ' cannot find `Python.h', the `can't link' message will
almost certainly appear.


File: conceptual.info,  Node: Manual configuration,  Prev: Problems with ``C compiler used for Python extension modules'',  Up: Problems with configure

8.1.7 Manual configuration
--------------------------

One of the most important by-products of running `./configure ' is a `config.h'
file that is used to build the CONCEPTUAL run-time library.  If the
approach outlined in *note Interpreting configure warnings:: proves
unable to convince CONCEPTUAL to build the library or other component,
it may be possible to address the failed tests manually by editing any
incorrect definitions in `config.h'.  In addition, running `./configure
' with the `--enable-broken-components' option will force `make' to
attempt to build and install _everything_, no matter how unlikely the
prospects of success are.  You may need to `make' individual rules from
the makefile in order to skip over unsalvageable parts of the build
process.

   The `--with-header-code' option to `configure' lets you specify a
single line of C code to insert into every test file that `configure'
generates and also into the header files used to build the run-time
library.  This extra line of code can be used to make up for missing
functionality or to load nonstandard header files.  If you need to
inject more than one line of code use `./configure
--with-header=code='#include "myheaders.h"'' and create an appropriate
`myheaders.h' file.

   Like all Autoconf scripts, `configure' runs a large number of small
test programs to characterize the user's system.  It keeps track of the
results of these tests in a set of "variables cache variables".  If a
cache variable is assigned a value on the command line, `configure'
will skip the associated test and simply assume that the cache
variable's value represents the test result.  Thus, cache variables
provide a fine level of control over the behavior of the `configure'
script and are a useful mechanism for working around the idiosyncrasies
of any given system.  *Note Cache Variables::, for a list of many of
the variables cache variables recognized by the CONCEPTUAL `configure'
script.

   It is highly unlikely that `./configure ' will fail completely.  If
it does, a working CONCEPTUAL system may still be possible.  Manually
edit `config.h' for your system.  (If `config.h' could not be created,
copy `config.h.in' to `config.h'.)  Do likewise for `ncptl.h'.
Finally, copy `Makefile.simple.in' to `Makefile.simple' if necessary
and replace all text bracketed by at signs with appropriate values or
blanks.  In particular, `@DEFS@' should be replaced by the string
`-DHAVE_CONFIG_H' as this instructs the various C files to include `config.h'.
*Note Building on problematic platforms::, for more information about `Makefile.simple'.
Although `Makefile.in' can be copied to `Makefile' and edited, doing so
requires many more string replacements.  The advantage is that the
result will support all of the options described in *note make::.


File: conceptual.info,  Node: Problems with make,  Next: Problems running,  Prev: Problems with configure,  Up: Troubleshooting

8.2 Problems with make
======================

Once CONCEPTUAL is configured, the next step is to build the various
components.  This section explains what to do if a compile fails or `make'
is otherwise unable to perform all of its operations.

* Menu:

* Failure following "missing" check::
* Too many columns in multitable item::  Building Emacs info files
* Can't find compiler_version.h::  Running `make install' properly
* Could not read symbols::      Linking with the correct libraries
* Incorrect tools/flags are utilized::  ncptl ignores configure variables
* Compaq compilers on Alpha CPUs::  Dealing with compiler idiosyncrasies
* undefined type found DEFINE____::  Thwarting an excessively "smart" cpp
* "makehelper.py config" fails::  Using Cygwin Python with a non-Cygwin cpp
* Building on problematic platforms::  Hacking makefiles by hand


File: conceptual.info,  Node: Failure following "missing" check,  Next: Too many columns in multitable item,  Prev: Problems with make,  Up: Problems with make

8.2.1 Failure following `missing' check
---------------------------------------

The `Makefile' produced by `./configure ' sometimes gets confused into
thinking that it needs to recreate one or more of the GNU Autotools
build files such as `aclocal.m4', `config.h.in', `configure', or `Makefile.in'.
A symptom of this confusion is an error message following an invocation
of the `missing' script:

     $ make
     cd . && /bin/sh ./config.status ncptl.h
     config.status: creating ncptl.h
     config.status: ncptl.h is unchanged
     cd . && /bin/sh /home/me/conceptual-1.4/missing --run autoheader
                        [Error message appears here.]

   The source of the problem is usually an incongruous timestamp on some
file relative to that of some other file.  Unfortunately, identifying
the files in question can be difficult.  The quick fix is to edit the `missing'
script, putting `exit 0' at the beginning of the file, right after the
`#! /bin/sh' line.  This tells the `Makefile' that none of the GNU
Autotools build files need to be recreated.


File: conceptual.info,  Node: Too many columns in multitable item,  Next: Can't find compiler_version.h,  Prev: Failure following "missing" check,  Up: Problems with make

8.2.2 `Too many columns in multitable item'
-------------------------------------------

Very old versions of `makeinfo' are unable to process `conceptual.texi'
into Emacs `info'-format documentation; instead, they fail with a large
number of `Too many columns in multitable item (max 1)' errors.  Simply
re-running `make' should bypass the failing documentation-building step.


File: conceptual.info,  Node: Can't find compiler_version.h,  Next: Could not read symbols,  Prev: Too many columns in multitable item,  Up: Problems with make

8.2.3 Can't find `compiler_version.h'
-------------------------------------

The CONCEPTUAL build process currently requires `make' to be executed
before `make install'.  Skipping the `make' step results in a `compiler_version.h'
error resembling the following:

     logfilefuncs.c:18:30: compiler_version.h: No such file or directory

   Ergo, make sure always to run `make' before running `make install'.


File: conceptual.info,  Node: Could not read symbols,  Next: Incorrect tools/flags are utilized,  Prev: Can't find compiler_version.h,  Up: Problems with make

8.2.4 `could not read symbols'
------------------------------

An attempt to link the CONCEPTUAL run-time library on one x86-64 Linux
platform aborted with the following error:

     /usr/lib/libpopt.so: could not read symbols: File in wrong format

An attempt on another x86-64 Linux platform aborted with a similar
error:

     /usr/lib/libpopt.so: could not read symbols: Invalid operation

   The problem on both platforms turned out to be that the
`/usr/lib/libpopt.so' is a 32-bit binary and could not be linked with a
64-bit library.  The solution was to configure with `./configure
LDFLAGS=-L/usr/lib64' to indicate that libraries should be read from
`/usr/lib64' instead of the default of `/usr/lib64'.


File: conceptual.info,  Node: Incorrect tools/flags are utilized,  Next: Compaq compilers on Alpha CPUs,  Prev: Could not read symbols,  Up: Problems with make

8.2.5 Incorrect tools/flags are utilized
----------------------------------------

You might find that although you specified a particular tool or flag at
configuration time (e.g., with `MPICC=mympicompiler'; see *note
configure::), the `ncptl' compiler seems to ignore it.  A likely
culprit is that an environment variable with the same name as the
configuration parameter is set (e.g., the `MPICC' environment variable
may be set to `othermpicompiler') and therefore overrides all prior
settings.  This situation sometimes arises when a compiler or MPI
library is made available using the Environment Modules system
(e.g., with the `module load' command).

   The solution is simply to undefine or properly redefine the offending
environment variable.  In most Unix environments the `env' command can
be used to redefine an environment variable for the duration of a
single command:

     env MPICC=mympicompiler ncptl --backend=c_mpi myprogram.ncptl


File: conceptual.info,  Node: Compaq compilers on Alpha CPUs,  Next: undefined type found DEFINE____,  Prev: Incorrect tools/flags are utilized,  Up: Problems with make

8.2.6 Compaq compilers on Alpha CPUs
------------------------------------

Although CONCEPTUAL builds fine on Alpha-based systems when using a `gcc'
compiler, Compaq's C compilers are sometimes problematic.  For
instance, the `libncptl_wrap.c' source file fails to compile on a
system with the following versions of the operating system, C compiler,
and Python interpreter:

     % uname -a
     OSF1 qsc14 V5.1 2650 alpha
     % cc -V
     Compaq C V6.5-011 on Compaq Tru64 UNIX V5.1B (Rev. 2650)
     Compiler Driver V6.5-003 (sys) cc Driver
     % python -V
     Python 2.3

   On the system that was tested, `cc' aborts with a set of `Missing
type specifier or type qualifier' messages.  The problem appears to be
that some of Compaq's standard C header files fail to `#include'
various header files they depend upon.  A workaround is to insert the
following C preprocessor directives in `libncptl_wrap.c' before the
line reading `#include "Python.h"':

     #include <sys/types.h>
     #include <sys/time.h>
     #include <sys/stat.h>


   A second problem with Compaq compilers on Alpha-based systems occurs
under Linux when using Compaq's `ccc' compiler:

     % uname -a
     Linux wi 2.4.21-3.7qsnet #2 SMP Fri Oct 17 14:08:00 MDT 2003 alpha unknown
     % ccc -V
     Compaq C T6.5-002 on Linux 2.4.21-3.7qsnet alpha
     Compiler Driver T6.5-001 (Linux) cc Driver
     Installed as ccc-6.5.6.002-1
     Red Hat Linux release 7.2 (Enigma)
     Using /usr/lib/gcc-lib/alpha-redhat-linux/2.96 (4).

When linking files into a shared object, `ccc' aborts with a
`[...]/.libs: file not recognized: Is a directory' error message.  The
problem appears to be that `libtool' is confused about the arguments
it's supposed to pass to the linker; `libtool' uses `--rpath' (two
hyphens) where the Compaq linker expects `-rpath' (one hyphen).  As a
workaround, you can edit the `libtool' file after running `./configure
' but before running `make'.  Simply replace `--rpath' with `-rpath' in
the following `libtool' line and the problem should go away:

     hardcode_libdir_flag_spec="\${wl}--rpath \${wl}\$libdir"


File: conceptual.info,  Node: undefined type found DEFINE____,  Next: "makehelper.py config" fails,  Prev: Compaq compilers on Alpha CPUs,  Up: Problems with make

8.2.7 `undefined type, found `DEFINE_____''
-------------------------------------------

The GCC 2.95.2 compiler on at least one MacOS 10.1 system complains
repeatedly about an `undefined type, found `DEFINE_____'' while trying
to preprocess a data file generated by `makehelper.py' and based upon
the contents of `config.h' `substitutions.dat'.  Fortunately, the
complaint is only a warning and can be ignored.  The problem is that
the C preprocessor performs "smart preprocessing" if given a filename
on the command line (as is the case here) but "basic preprocessing"
when reading from the standard input device.  Because the input does
not represent syntactically correct C code--the C preprocessor is used
only as a convenient device for performing macro substitutions--the
syntax-aware smart preprocessing fails.  However, the C preprocessor
then reprocesses the file with basic preprocessing (as indicated by the
message `cpp-precomp: warning: errors during smart preprocessing,
retrying in basic mode') and succeeds.


File: conceptual.info,  Node: "makehelper.py config" fails,  Next: Building on problematic platforms,  Prev: undefined type found DEFINE____,  Up: Problems with make

8.2.8 `makehelper.py config' fails
----------------------------------

When `makehelper.py' is run with the `config' option, it generates a
temporary `.c' file that it runs through the C preprocessor.  Problems
(e.g., a `gcc.exe: no input files' error message) may occur when
running under Cygwin (a Unix-like user environment for Microsoft
Windows) with a Cygwin Python interpreter but a non-Cygwin C preprocessor
(e.g., MinGW's) because `makehelper.py' may try to pass a Unix-style
filename to the C preprocessor, which expects to receive a
Windows-style filename.

   A workaround is to specify explicitly a temporary directory for `makehelper.py'
to use.  Use forward slashes and filenames without spaces
(e.g., DOS-style 8.3 filenames) as in the following example:

     make TEMP=C:/DOCUME~1/user/LOCALS~1/Temp


File: conceptual.info,  Node: Building on problematic platforms,  Prev: "makehelper.py config" fails,  Up: Problems with make

8.2.9 Building on problematic platforms
---------------------------------------

Some experimental systems require rather specialized build procedures
that thwart CONCEPTUAL's standard makefile.  Unfortunately, `Makefile'
is complex and difficult to edit by hand.  Users comfortable with Automake
should edit `Makefile.am'--which is used to generate `Makefile'--and
re-run `automake', `autoconf', and `./configure ' as described in *note
make::.

   CONCEPTUAL includes an alternate Makefile called `Makefile.simple'
(generated at configuration time from `Makefile.simple.in').  `Makefile.simple'
is a stripped-down version of `Makefile' that is designed to be easy to
edit by hand.  `make -f Makefile.simple' builds a static version of the
CONCEPTUAL run-time library in the current directory.  `make -f Makefile.simple clean'
deletes the run-time library and all of the object files used to build
it.  `Makefile.simple' supports no other features.  The intention is to
provide the bare minimum needed to get backends such as `c_mpi' to
produce executable programs even when running in unusual environments.


File: conceptual.info,  Node: Problems running,  Next: When all else fails,  Prev: Problems with make,  Up: Troubleshooting

8.3 Problems running
====================

After CONCEPTUAL is configured, compiled, built, and installed, there is
still the chance that CONCEPTUAL-generated executables fail to run.
This section addresses some common problems and presents their
solutions.

   As a quick tip, a very conservative way to run a CONCEPTUAL program
is with the `NCPTL_NOFORK' environment variable set to `1', the `NCPTL_CHECKPOINT'
environment variable set to `0', and with `--no-trap=1-63' on the
command line.  Such usage should work around some of the most
common--and some of the hardest to diagnose--problems that may impact a
CONCEPTUAL program.  Read the corresponding sections (*note
Miscellaneous mysterious hangs or crashes::; *note Extremely noisy
measurements::; and, *note Keeping programs from dying on a signal::)
for information about the drawbacks of each of the preceding settings.

* Menu:

* ``cannot open shared object file''::  Preventing problems with libncptl.so
* Miscellaneous mysterious hangs or crashes::  Programs die inexplicably
* Extremely noisy measurements::  Data exhibits excessive variability
* Keeping programs from dying on a signal::  Handling unexpected terminations
* ``Unaligned access'' warnings::  What these mean and how to prevent them
* ``Unable to determine the OS page size''::  Specifying page sizes
* Invalid timing measurements::  coNCePTuaL's timer is completely wrong
* ``TeX capacity exceeded''::   Problems drawing complex diagrams with latex_vis
* Bad bounding boxes from latex_vis::  Generated pictures are truncated


File: conceptual.info,  Node: ``cannot open shared object file'',  Next: Miscellaneous mysterious hangs or crashes,  Prev: Problems running,  Up: Problems running

8.3.1 `cannot open shared object file'
--------------------------------------

A common problem on many workstation clusters is that the head node (on
which `./configure ' is run) has more libraries installed than do the
compute nodes (on which CONCEPTUAL programs themselves are run).
Consequently, CONCEPTUAL programs that compile and link properly on the
head node will fail with a `cannot open shared object file' error if
they try to dynamically link a shared object that is absent on the
compute nodes.

   Ideally, the missing shared objects should be installed on each of
the compute nodes.  If they cannot be installed in their standard
locations (e.g., `/usr/lib'), they can be installed elsewhere (e.g., in
the user's home directory) and that location can be pointed to using `-rpath'
or `LD_LIBRARY_PATH', as described below.  Alternatively, `configure'
can be instructed to disregard certain libraries--even if they exist on
the head node--by passing the `--with-ignored-libs' option to `configure'
(*note configure::).  For example, if `libpopt.so' is not installed on
the compute nodes one can run `./configure --with-ignored-libs=popt' to
prevent `libpopt.so' from being used.

   The `--with-ignored-libs' option is of little use if the CONCEPTUAL
library itself cannot be found at run time.  By default, `make' will
build and `make install' will install both a static and a dynamic
version of the CONCEPTUAL run-time library.  Most linkers give
precedence to the dynamic library over the static library unless the
static library is requested explicitly.  As a consequence, the dynamic
version of the CONCEPTUAL run-time library needs to be available at
program-load time in order to avoid error messages like the following:

     a.out: error while loading shared libraries: libncptl.so.0: cannot open
     shared object file: No such file or directory

   There are a few alternatives for pointing the dynamic loader to the
CONCEPTUAL run-time library.  On systems that support it, the best
option is the `-rpath' approach described in *note Implicit
dynamic-library search paths::.  The second-best option is to add the
directory in which `libncptl.so' was installed (by default,
`/usr/local/lib') to your `LD_LIBRARY_PATH' environment variable.
Finally, as a last resort, you can use the `--disable-shared'
configuration option (*note configure::) to prevent CONCEPTUAL from
building the dynamic version of the run-time library altogether,
thereby forcing the linker to use the static version:

     make uninstall
     make clean
     ./configure --disable-shared ...
     make
     make install

As mentioned in *note configure::, however, `libncptlmodule.so' can't
be built when `--disable-shared' is in effect.


File: conceptual.info,  Node: Miscellaneous mysterious hangs or crashes,  Next: Extremely noisy measurements,  Prev: ``cannot open shared object file'',  Up: Problems running

8.3.2 Miscellaneous mysterious hangs or crashes
-----------------------------------------------

In some implementations of the software stack for InfiniBand--and
possibly for some other networks as well--invocations of the `fork()'
system call made while the network device is open can corrupt process
memory and hang or crash the corresponding process.  (On Unix and
Unix-like operating systems this is typically via a segmentation fault.)

   The workaround is to build CONCEPTUAL using the `--without-fork'
option (*note configure::).  Alternatively, you can set the `NCPTL_NOFORK'
environment variable when running a CONCEPTUAL program.  Either option
suppresses the CONCEPTUAL run-time library's use of all
process-spawning functions.  *Note Environment Variables::, for a
description of `NCPTL_NOFORK''s side effects.  The same description
also applies to `--without-fork'.


   The C library that comes bundled with a lightweight run-time kernel
or other custom operating system may provide broken versions of some of
the functions on which the CONCEPTUAL run-time library relies.  If a
debugger or crash-analysis tool indicates that a particular function is
problematic it may be possible to disable that function at
configuration time.  For example, the current (at the time of this
writing) release of Red Storm's software stack includes a faulty `getrusage()'
function that crashes consistently.  Observing that `configure' checks
for `getrusage()' we searched the generated `config.log' file and
encountered the corresponding shell variable, `ac_cv_func_getrusage',
which was set to `yes'.  Rerunning `./configure ' with
`ac_cv_func_getrusage=no' on the command line disabled the CONCEPTUAL
run-time library's use of `getrusage()' and thereby resulted in
crash-free execution of CONCEPTUAL programs.


File: conceptual.info,  Node: Extremely noisy measurements,  Next: Keeping programs from dying on a signal,  Prev: Miscellaneous mysterious hangs or crashes,  Up: Problems running

8.3.3 Extremely noisy measurements
----------------------------------

Sometimes a CONCEPTUAL program runs to completion but the data written
to the log files exhibit high levels of variability across runs or even
across trials within a single run.  A possible source of this
variability--especially for long-running programs running on a large
number of processors--is the run-time library's log-file checkpointing
mechanism.  Because each process in a CONCEPTUAL programs writes its
own log file, poorly scalable shared filesystems, limited spare network
bandwidth, and asynchronous operating-system buffer flushes may each
impact program performance in an unpredictable manner and at
unpredictable times.

   Setting the `NCPTL_CHECKPOINT' environment variable to `0' disables
log-file checkpointing and may thereby reduce some of the data
variability.  The caveat is that a program that aborts abnormally will
leave behind _no_ data in its log files.  *Note Environment
Variables::, for more information about `NCPTL_CHECKPOINT'.


File: conceptual.info,  Node: Keeping programs from dying on a signal,  Next: ``Unaligned access'' warnings,  Prev: Extremely noisy measurements,  Up: Problems running

8.3.4 Keeping programs from dying on a signal
---------------------------------------------

By default, CONCEPTUAL programs terminate upon receiving _any_
unexpected signal.  The error message list the signal number and, if
available, a human-readable signal name:

     myprogram: Received signal 28 (Window changed); specify --no-trap=28 to
     ignore

   The motivation behind this decision to abort on unexpected signals is
that signal-handling adversely affects a program's performance.  Hence,
by running to completion, a program indicates that it did not receive
any unexpected signals.  However, some messaging layers use signals
internally (most commonly `SIGUSR1' and `SIGUSR2') to coordinate helper
processes.  To permit a program to deliver such signals to the
messaging layer a user should use the program's `--no-trap'
command-line option as described in *note Running coNCePTuaL programs::.


File: conceptual.info,  Node: ``Unaligned access'' warnings,  Next: ``Unable to determine the OS page size'',  Prev: Keeping programs from dying on a signal,  Up: Problems running

8.3.5 `Unaligned access' warnings
---------------------------------

On some platforms you may encounter messages like the following written
to the console and/or various system log files (e.g., `/var/log/messages'):

     myprog(25044): unaligned access to 0x6000000000001022,
     ip=0x40000000000009e1

Alternatively:

     Unaligned access pid=7890104 <myprog> va=0x140004221 pc=0x1200012b4
     ra=0x1200012a4 inst=0xb449fff8

   What's happening is that some CPUs require n-byte-wide data to be
aligned on an n-byte boundary.  For example, a 64-bit datatype can be
accessed properly only from memory locations whose address is a
multiple of 64 bits (8 bytes).  On some platforms, misaligned accesses
abnormally terminate the program, typically with a `SIGBUS' signal.  On
other platforms, misaligned accesses interrupt the operating system.
The operating system fixes the access by splitting it into multiple
aligned accesses plus some bit masking and shifting and then notifying
the user and/or system administrator that a fixup occurred.

   CONCEPTUAL's `configure' script automatically determines what data
alignments are allowed by the architecture but it has no way to
determine if fixups occurred as these are transparent to programs.  The
result is annoying "unaligned access" messages such as those quoted
above.  One solution is to use the `--with-alignment' option to `configure'
to specify explicitly the minimum data alignment that CONCEPTUAL should
be permitted to use.  Alternatively, some operating systems provide a
mechanism to cause misaligned accesses to result in a `SIGBUS' signal
instead of a fixup and notification message.  On Linux/IA-64 this is
achieved with the command `prctl --unaligned=signal'.  On OSF1/Alpha
the equivalent command is `uac p sigbus'.  Be sure to rerun `configure'
after issuing those commands to make it reexamine the set of valid data
alignments.


File: conceptual.info,  Node: ``Unable to determine the OS page size'',  Next: Invalid timing measurements,  Prev: ``Unaligned access'' warnings,  Up: Problems running

8.3.6 `Unable to determine the OS page size'
--------------------------------------------

To implement `PAGE ALIGNED' messages (*note Message alignment::) a
program needs to be able to query the operating system's page size.
The CONCEPTUAL run-time library performs this query using one of the `getpagesize()'
or `sysconf()' operating-system calls.  If neither call is available or
functional the run-time library aborts with an `Unable to determine the
OS page size' error.

   As a workaround, `configure' provides a `--with-page-size' option
that enables the user to manually specify the page size.  Because any
manually specified value is prone to error, CONCEPTUAL log files
include a `Page size was specified manually at configuration time'
warning if the run-time library was configured using `--with-page-size'.


File: conceptual.info,  Node: Invalid timing measurements,  Next: ``TeX capacity exceeded'',  Prev: ``Unable to determine the OS page size'',  Up: Problems running

8.3.7 Invalid timing measurements
---------------------------------

Although the CONCEPTUAL `configure' script is usually good at selecting
a mechanism for measuring elapsed time, there are a few systems that
confuse the script.  For example, different Intel processors use
different mechanisms for mapping cycle counts to time (cf.
`http://en.wikipedia.org/wiki/RDTSC'); the correct mapping cannot
always be determined at configuration time and may require
administrator privileges to calculate.  Consequently, if `configure'
determines that the CONCEPTUAL timer should read the cycle counter
directly, incorrect times may be reported.

   The best way to test the timer quality is to run the `validatetimer'
program (*note Validating the coNCePTuaL timer::).  If the difference
between wall-clock time and CONCEPTUAL-reported time is great, the `--with-gettimeofday'
configuration option (*note configure::) is usually a safe bet for
improving accuracy, albeit at a slight cost in measurement overhead.


File: conceptual.info,  Node: ``TeX capacity exceeded'',  Next: Bad bounding boxes from latex_vis,  Prev: Invalid timing measurements,  Up: Problems running

8.3.8 `TeX capacity exceeded'
-----------------------------

TeX--and by consequence, LaTeX--does not use dynamically allocated
memory.  Therefore, attempting to produce a very large diagram with the `latex_vis'
backend (*note The latex_vis backend::) will likely exceed TeX's
hardwired memory capacity:

     ! TeX capacity exceeded, sorry [main memory size=350001].
     \psm@endnode@i ... \endgroup \psm@endmath \egroup
                                                       \use@par \@psttrue
     l.489 \task
                {0} & \task{1} \\
     No pages of output.

TeX/LaTeX's memory capacity can be increased but the mechanism for
doing so varies from one TeX distribution to another and is rarely
straightforward.  See
`http://www.tex.ac.uk/cgi-bin/texfaq2html?label=enlarge' for a few
terse pointers.  In general, it is best to try to minimize the number
of loop repetitions when running programs through the `latex_vis'
backend.

   An alternative is to use a prebuilt large-memory `latex'.  Some TeX
distributions come with a `hugelatex' executable, which is just like
`latex' but compiled with larger memory limits.  `ncptl' can be told to
use `hugelatex' by setting the `LATEX' environment variable (e.g., with
`env LATEX=hugelatex ncptl ...').  This may be the most convenient way
to produce complex diagrams with `latex_vis' when simplifying the run
is not an option.


File: conceptual.info,  Node: Bad bounding boxes from latex_vis,  Prev: ``TeX capacity exceeded'',  Up: Problems running

8.3.9 Bad bounding boxes from `latex_vis'
-----------------------------------------

Very tall program visualizations are susceptible to Ghostscript
bug #202735, "bbox device doesn't allow min coords < 0".  `latex_vis'
attempts to work around that bug by defining a large PostScript
`ImagingBBox' as described in
`http://bugs.ghostscript.com/show_bug.cgi?id=202735'.  While no
problems with the `latex_vis' workaround have yet been reported, if
problems do occur it should be sufficient to set the `GS' environment
variable to `:' or the name of a program known not to exist.  `latex_vis'
will then issue a warning message and generate an EPS file with an
acceptable but slightly loose bounding box, as mentioned in *note The
latex_vis backend::.


File: conceptual.info,  Node: When all else fails,  Prev: Problems running,  Up: Troubleshooting

8.4 When all else fails
=======================

The CONCEPTUAL project pages on SourceForge.net
(http://sourceforge.net/) provide a variety of mechanisms for providing
feedback to the CONCEPTUAL developers:

Mailing lists
     Read and post messages on the CONCEPTUAL mailing lists at
     `http://sourceforge.net/mail/?group_id=117615'.

Trackers
     Search for old or post new bug reports
     (http://sourceforge.net/tracker/?group_id=117615&atid=678627),
     feature requests
     (http://sourceforge.net/tracker/?group_id=117615&atid=678630), or
     code patches
     (http://sourceforge.net/tracker/?group_id=117615&atid=678629) at
     `http://sourceforge.net/tracker/?group_id=117615'.


File: conceptual.info,  Node: Reserved Words,  Next: Backend Developer's Reference,  Prev: Troubleshooting,  Up: Top

Appendix A Reserved Words
*************************

As mentioned in *note Primitives::, not all identifiers can be used as
variables.  The following sections provide a complete list of
identifiers that are forbidden as variable names.  These identifiers
fall into two categories: keywords, which are never allowed as variable
names, and predeclared variables, which are "read-only" variables; they
can be utilized just like any other variables but cannot be redeclared.

* Menu:

* Keywords::                    List of coNCePTuaL keywords
* Predeclared variables::       List of variables made available to programs


File: conceptual.info,  Node: Keywords,  Next: Predeclared variables,  Prev: Reserved Words,  Up: Reserved Words

A.1 Keywords
============

The following is a list of all currently defined keywords in the
CONCEPTUAL language.  It is an error to try to use any of these as
identifiers.

   * `A'

   * `ABS'

   * `ABSOLUTE'

   * `AGGREGATES'

   * `ALIGNED'

   * `ALL'

   * `AN'

   * `AND'

   * `ARE'

   * `ARITHMETIC'

   * `AS'

   * `ASSERT'

   * `ASSIGNED'

   * `ASYNCHRONOUSLY'

   * `AWAIT'

   * `AWAITS'

   * `BACKEND'

   * `BE'

   * `BIT'

   * `BITS'

   * `BUFFER'

   * `BUFFERS'

   * `BUT'

   * `BYTE'

   * `BYTES'

   * `CBRT'

   * `CEILING'

   * `COMES'

   * `COMPLETION'

   * `COMPLETIONS'

   * `COMPUTE'

   * `COMPUTES'

   * `COUNTERS'

   * `CURRENT'

   * `DATA'

   * `DAY'

   * `DAYS'

   * `DECLARES'

   * `DEFAULT'

   * `DEVIATION'

   * `DIVIDES'

   * `DOUBLEWORD'

   * `DOUBLEWORDS'

   * `EACH'

   * `EVEN'

   * `EXECUTE'

   * `EXECUTES'

   * `FACTOR10'

   * `FINAL'

   * `FLOOR'

   * `FOR'

   * `FROM'

   * `GEOMETRIC'

   * `GIGABYTE'

   * `GREATER'

   * `GROUP'

   * `HALFWORD'

   * `HALFWORDS'

   * `HARMONIC'

   * `HISTOGRAM'

   * `HOUR'

   * `HOURS'

   * `IF'

   * `IN'

   * `INTEGER'

   * `INTEGERS'

   * `INTO'

   * `IS'

   * `IT'

   * `ITS'

   * `KILOBYTE'

   * `KNOMIAL_CHILD'

   * `KNOMIAL_CHILDREN'

   * `KNOMIAL_PARENT'

   * `LANGUAGE'

   * `LESS'

   * `LET'

   * `LOG'

   * `LOG10'

   * `LOGS'

   * `MAX'

   * `MAXIMUM'

   * `MEAN'

   * `MEDIAN'

   * `MEGABYTE'

   * `MEMORY'

   * `MESH_COORDINATE'

   * `MESH_DISTANCE'

   * `MESH_NEIGHBOR'

   * `MESSAGE'

   * `MESSAGES'

   * `MICROSECOND'

   * `MICROSECONDS'

   * `MILLISECOND'

   * `MILLISECONDS'

   * `MIN'

   * `MINIMUM'

   * `MINUTE'

   * `MINUTES'

   * `MISALIGNED'

   * `MOD'

   * `MULTICAST'

   * `MULTICASTS'

   * `MY'

   * `NONUNIQUE'

   * `NOT'

   * `ODD'

   * `OF'

   * `OR'

   * `OTHER'

   * `OTHERWISE'

   * `OUTPUT'

   * `OUTPUTS'

   * `PAGE'

   * `PAGES'

   * `PLUS'

   * `PROCESSOR'

   * `PROCESSORS'

   * `QUADWORD'

   * `QUADWORDS'

   * `RANDOM'

   * `RANDOM_GAUSSIAN'

   * `RANDOM_PARETO'

   * `RANDOM_POISSON'

   * `RANDOM_UNIFORM'

   * `REAL'

   * `RECEIVE'

   * `RECEIVES'

   * `REDUCE'

   * `REDUCES'

   * `REGION'

   * `REPETITION'

   * `REPETITIONS'

   * `REQUIRE'

   * `RESET'

   * `RESETS'

   * `RESTORE'

   * `RESTORES'

   * `RESULT'

   * `RESULTS'

   * `ROOT'

   * `ROUND'

   * `SECOND'

   * `SECONDS'

   * `SEND'

   * `SENDS'

   * `SIZED'

   * `SLEEP'

   * `SLEEPS'

   * `SQRT'

   * `STANDARD'

   * `STORE'

   * `STORES'

   * `STRIDE'

   * `SUCH'

   * `SUM'

   * `SYNCHRONIZATION'

   * `SYNCHRONIZE'

   * `SYNCHRONIZES'

   * `SYNCHRONOUSLY'

   * `TAG'

   * `TASK'

   * `TASKS'

   * `THAN'

   * `THAT'

   * `THE'

   * `THEIR'

   * `THEM'

   * `THEN'

   * `TIME'

   * `TIMES'

   * `TO'

   * `TOUCH'

   * `TOUCHES'

   * `TOUCHING'

   * `TREE_PARENT'

   * `TREE_CHILD'

   * `UNALIGNED'

   * `UNIQUE'

   * `UNSUSPECTING'

   * `USING'

   * `VALUE'

   * `VARIANCE'

   * `VERIFICATION'

   * `VERSION'

   * `WARMUP'

   * `WHERE'

   * `WHILE'

   * `WHO'

   * `WITH'

   * `WITHOUT'

   * `WORD'

   * `WORDS'

   * `XOR'



File: conceptual.info,  Node: Predeclared variables,  Prev: Keywords,  Up: Reserved Words

A.2 Predeclared variables
=========================

CONCEPTUAL predeclares a set of variables that programs can use but not
redeclare.  These variables and their descriptions are listed below.

`bit_errors'
     Total number of bit errors observed

`bytes_received'
     Total number of bytes received

`bytes_sent'
     Total number of bytes sent

`elapsed_usecs'
     Elapsed time in microseconds

`msgs_received'
     Total number of messages received

`msgs_sent'
     Total number of messages sent

`num_tasks'
     Number of tasks running the program

`total_bytes'
     Sum of bytes sent and bytes received

`total_msgs'
     Sum of messages sent and messages received


   As should be evident from their descriptions, CONCEPTUAL's
predeclared variables are updated dynamically.  Each access can
potentially return a different result.  Furthermore, unlike
user-declared variables, predeclared variables in can have a different
value on each task.

   The following notes clarify the semantics that relate to the updating
of some of the preceding variables:

`ASYNCHRONOUSLY' (*note Blocking semantics::)
     A message that is _sent_ `ASYNCHRONOUSLY' immediately increments
     each of `msgs_sent' and `total_msgs' by 1 and each of `bytes_sent'
     and `total_bytes' by the message size.  A message that is
     _received_ `ASYNCHRONOUSLY' increments none of the predeclared
     variables.  However, after the receiving task `AWAITS COMPLETION'
     (*note Awaiting completion::) it increments each of `msgs_received'
     and `total_msgs' by 1 and each of `bytes_received' and `total_bytes'
     by the message size.

`MULTICASTS' (*note Multicasting::)
     None of the byte or message variables are updated as part of a
     multicast operation, regardless of how the underlying messaging
     layer implements multicasts.

`SYNCHRONIZES' (*note Synchronizing::)
     None of the byte or message variables are updated as part of a
     barrier synchronization, regardless of how the underlying
     messaging layer implements barriers.


File: conceptual.info,  Node: Backend Developer's Reference,  Next: Environment Variables,  Prev: Reserved Words,  Up: Top

Appendix B Backend Developer's Reference
****************************************

Programmers wishing to develop their own CONCEPTUAL backends can refer
to the information presented in this appendix as a complement to the
more tutorial-in-nature *note Implementation::.

* Menu:

* Method calls::                Methods a backend must implement
* C hooks::                     Methods a C-based backend may implement
* Event types::                 Types of events defined by c_generic programs
* Representing aggregate functions::  An enumerated type of aggregates


File: conceptual.info,  Node: Method calls,  Next: C hooks,  Prev: Backend Developer's Reference,  Up: Backend Developer's Reference

B.1 Method calls
================

The following method calls must be defined when writing a CONCEPTUAL
backend from scratch.  They are invoked indirectly as part of PLY's AST
traversal.  *Note Backend creation::, for more information.

   * `n_add_expr'

   * `n_aggregate_expr'

   * `n_aggregate_func'

   * `n_an'

   * `n_assert_stmt'

   * `n_awaits_completion'

   * `n_backend_decl'

   * `n_backend_stmt'

   * `n_buffer_number'

   * `n_buffer_offset'

   * `n_computes_for'

   * `n_data_multiplier'

   * `n_data_type'

   * `n_dimension'

   * `n_dimension_list'

   * `n_empty_stmt'

   * `n_eq_expr'

   * `n_expr_list'

   * `n_for_count'

   * `n_for_each'

   * `n_for_each_expr'

   * `n_for_time'

   * `n_func_call'

   * `n_ident'

   * `n_if_stmt'

   * `n_ifelse_expr'

   * `n_integer'

   * `n_item_size'

   * `n_let_binding'

   * `n_let_binding_list'

   * `n_let_stmt'

   * `n_log_expr_list'

   * `n_log_expr_list_elt'

   * `n_log_flush_stmt'

   * `n_log_stmt'

   * `n_mcast_stmt'

   * `n_message_alignment'

   * `n_message_spec'

   * `n_mult_expr'

   * `n_my_task'

   * `n_no_touching'

   * `n_output_stmt'

   * `n_param_decl'

   * `n_power_expr'

   * `n_processor_stmt'

   * `n_program'

   * `n_range'

   * `n_range_list'

   * `n_real'

   * `n_receive_attrs'

   * `n_receive_stmt'

   * `n_recv_buffer_number'

   * `n_reduce_message_spec'

   * `n_reduce_stmt'

   * `n_rel_conj_expr'

   * `n_rel_disj_expr'

   * `n_reset_stmt'

   * `n_restore_stmt'

   * `n_send_attrs'

   * `n_send_stmt'

   * `n_simple_stmt_list'

   * `n_sleeps_for'

   * `n_store_stmt'

   * `n_stride'

   * `n_string'

   * `n_string_or_expr_list'

   * `n_string_or_log_comment'

   * `n_sync_stmt'

   * `n_tag'

   * `n_task_expr'

   * `n_time_unit'

   * `n_top_level_stmt'

   * `n_touch_buffer_stmt'

   * `n_touch_repeat_count'

   * `n_touch_stmt'

   * `n_touching'

   * `n_trivial_node'

   * `n_unary_expr'

   * `n_unique'

   * `n_verification'

   * `n_version_decl'

   * `n_where_expr'


File: conceptual.info,  Node: C hooks,  Next: Event types,  Prev: Method calls,  Up: Backend Developer's Reference

B.2 C hooks
===========

To save the backend developer from having to implement CONCEPTUAL
backends entirely from scratch, CONCEPTUAL provides a `codegen_c_generic.py'
module that defines a base class for code generators that output C
code.  The base class handles the features that are specific to C but
independent of any messaging library.  Derived classes need only define
those "hook" functions that are needed to implement library-specific
functionality.

   Hooks are named after the method from which they're called but with
an all-uppercase tag appended.  The following list shows each
hook-calling method in `codegen_c_generic.py' and the set of hooks it
calls.  *Note Hook methods::, for more information.

   * `code_declare_datatypes'
        - `code_declare_datatypes_EXTRA_EVENTS'

        - `code_declare_datatypes_EXTRA_EVENT_STATE'

        - `code_declare_datatypes_EXTRA_EVS'

        - `code_declare_datatypes_MCAST_STATE'

        - `code_declare_datatypes_POST'

        - `code_declare_datatypes_PRE'

        - `code_declare_datatypes_RECV_STATE'

        - `code_declare_datatypes_REDUCE_STATE'

        - `code_declare_datatypes_SEND_STATE'

        - `code_declare_datatypes_SYNC_STATE'

        - `code_declare_datatypes_WAIT_STATE'

   * `code_declare_globals'
        - `code_declare_globals_DUMMY_VAR'

        - `code_declare_globals_EXTRA'

   * `code_def_alloc_event'
        - `code_def_alloc_event_DECLS'

        - `code_def_alloc_event_POST'

        - `code_def_alloc_event_PRE'

   * `code_def_exit_handler'
        - `code_def_exit_handler_BODY'

   * `code_def_finalize'
        - `code_def_finalize_DECL'

        - `code_def_finalize_POST'

        - `code_def_finalize_PRE'

   * `code_def_init_check_pending'
        - `code_def_init_check_pending_POST'

        - `code_def_init_check_pending_PRE'

   * `code_def_init_cmd_line'
        - `code_def_init_cmd_line_POST_ARGS'

        - `code_def_init_cmd_line_POST_PARSE'

        - `code_def_init_cmd_line_PRE_ARGS'

        - `code_def_init_cmd_line_PRE_PARSE'

   * `code_def_init_decls'
        - `code_def_init_decls_POST'

        - `code_def_init_decls_PRE'

   * `code_def_init_init'
        - `code_def_init_init_POST'

        - `code_def_init_init_PRE'

   * `code_def_init_misc'
        - `code_def_init_misc_EXTRA'

        - `code_def_init_misc_PRE_LOG_OPEN'

   * `code_def_init_msg_mem'
        - `code_def_init_msg_mem_EACH_TAG'

        - `code_def_init_msg_mem_POST'

        - `code_def_init_msg_mem_PRE'

   * `code_def_init_reseed'
        - `code_def_init_reseed_BCAST'

   * `code_def_init_seed'
        - `code_def_init_seed_POST'

        - `code_def_init_seed_PRE'

   * `code_def_init_uuid'
        - `code_def_init_uuid_BCAST'

   * `code_def_mark_used'
        - `code_def_mark_used_POST'

        - `code_def_mark_used_PRE'

   * `code_def_procev'
        - `code_def_procev_DECL'

        - `code_def_procev_EVENTS_DECL'

        - `code_def_procev_EXTRA_EVENTS'

        - `code_def_procev_POST'

        - `code_def_procev_POST_SWITCH'

        - `code_def_procev_PRE'

        - `code_def_procev_PRE_SWITCH'

   * `code_def_procev_arecv'
        - `code_def_procev_arecv_BODY'

   * `code_def_procev_asend'
        - `code_def_procev_asend_BODY'

   * `code_def_procev_etime'
        - `code_def_procev_etime_REDUCE_MIN'

   * `code_def_procev_mcast'
        - `code_def_procev_mcast_BODY'

   * `code_def_procev_newstmt'
        - `code_def_procev_newstmt_BODY'

   * `code_def_procev_recv'
        - `code_def_procev_recv_BODY'

   * `code_def_procev_reduce'
        - `code_def_procev_reduce_BODY'

   * `code_def_procev_repeat'
        - `code_def_procev_repeat_BODY'

   * `code_def_procev_send'
        - `code_def_procev_send_BODY'

   * `code_def_procev_sync'
        - `code_def_procev_sync_BODY'

   * `code_def_procev_wait'
        - `code_def_procev_wait_BODY_RECVS'

        - `code_def_procev_wait_BODY_SENDS'

   * `code_def_small_funcs'
        - `code_def_small_funcs_POST'

        - `code_def_small_funcs_PRE'

   * `code_define_functions'
        - `code_define_functions_INIT_COMM_1'

        - `code_define_functions_INIT_COMM_2'

        - `code_define_functions_INIT_COMM_3'

        - `code_define_functions_POST'

        - `code_define_functions_PRE'

   * `code_define_macros'
        - `code_define_macros_POST'

        - `code_define_macros_PRE'

   * `code_define_main'
        - `code_define_main_DECL'

        - `code_define_main_POST_EVENTS'

        - `code_define_main_POST_INIT'

        - `code_define_main_PRE_EVENTS'

        - `code_define_main_PRE_INIT'

   * `code_output_header_comments'
        - `code_output_header_comments_EXTRA'

   * `code_specify_include_files'
        - `code_specify_include_files_POST'

        - `code_specify_include_files_PRE'

   * `code_synchronize_all'
        - `code_synchronize_all_BODY'

   * `n_for_count'
        - `n_for_count_SYNC_ALL'

   * `n_mcast_stmt'
        - `n_mcast_stmt_DECL'

        - `n_mcast_stmt_INIT'

        - `n_mcast_stmt_MANY_MANY'

        - `n_mcast_stmt_POST'

        - `n_mcast_stmt_PRE'

   * `n_recv_stmt'
        - `n_recv_stmt_BODY'

   * `n_reduce_stmt'
        - `n_reduce_stmt_DECL'

        - `n_reduce_stmt_HAVE_PEERS'

        - `n_reduce_stmt_INIT'

        - `n_reduce_stmt_INIT2'

        - `n_reduce_stmt_POST'

        - `n_reduce_stmt_PRE'

   * `n_send_stmt'
        - `n_send_stmt_BODY'

   * `n_sync_stmt'
        - `n_sync_stmt_DECL'

        - `n_sync_stmt_INIT'

        - `n_sync_stmt_POST'

        - `n_sync_stmt_PRE'


File: conceptual.info,  Node: Event types,  Next: Representing aggregate functions,  Prev: C hooks,  Up: Backend Developer's Reference

B.3 Event types
===============

Programs generated by `codegen_c_generic.py' define the following event
types:

`EV_ARECV'
     Asynchronous receive

`EV_ASEND'
     Asynchronous send

`EV_BTIME'
     Beginning of a timed loop

`EV_DELAY'
     Spin or sleep

`EV_ETIME'
     Ending of a timed loop

`EV_FLUSH'
     Compute aggregate functions for log-file columns

`EV_MCAST'
     Synchronous multicast

`EV_NEWSTMT'
     Beginning of a new top-level statement

`EV_RECV'
     Synchronous receive

`EV_REDUCE'
     Reduction with or without a subsequent multicast

`EV_REPEAT'
     Repeatedly process the next N events

`EV_RESET'
     Reset counters

`EV_RESTORE'
     Restore the previously pushed counter values

`EV_SEND'
     Synchronous send

`EV_STORE'
     Store all counters' current values

`EV_SUPPRESS'
     Suppress writing to the log and standard output

`EV_SYNC'
     Barrier synchronization

`EV_TOUCH'
     Touch a region of memory

`EV_WAIT'
     Wait for all asynchronous sends/receives to complete

`EV_CODE'
     None of the above

   *note Generated code::, motivates the use of event-based execution
for CONCEPTUAL programs.


File: conceptual.info,  Node: Representing aggregate functions,  Prev: Event types,  Up: Backend Developer's Reference

B.4 Representing aggregate functions
====================================

The `LOG_AGGREGATE' enumerated type, defined in `ncptl.h', accepts the
following values:

`NCPTL_FUNC_NO_AGGREGATE'
     Log all data points.

`NCPTL_FUNC_MEAN'
     Log only the arithmetic mean.

`NCPTL_FUNC_HARMONIC_MEAN'
     Log only the harmonic mean.

`NCPTL_FUNC_GEOMETRIC_MEAN'
     Log only the geometric mean.

`NCPTL_FUNC_MEDIAN'
     Log only the median.

`NCPTL_FUNC_MAD'
     Log only the median absolute deviation.

`NCPTL_FUNC_STDEV'
     Log only the standard deviation.

`NCPTL_FUNC_VARIANCE'
     Log only the variance.

`NCPTL_FUNC_SUM'
     Log only the sum.

`NCPTL_FUNC_MINIMUM'
     Log only the minimum.

`NCPTL_FUNC_MAXIMUM'
     Log only the maximum.

`NCPTL_FUNC_FINAL'
     Log only the final measurement.

`NCPTL_FUNC_ONLY'
     Log any data point, aborting if they're not all identical.

`NCPTL_FUNC_HISTOGRAM'
     Log a histogram of the data points



File: conceptual.info,  Node: Environment Variables,  Next: Cache Variables,  Prev: Backend Developer's Reference,  Up: Top

Appendix C Environment Variables
********************************

The CONCEPTUAL compiler (`ncptl') honors the following environment
variables:

`NCPTL_BACKEND'
     Name a default backend for the compiler to use.  For example,
     setting `NCPTL_BACKEND' to `c_udgram' tells `ncptl' to use the `c_udgram'
     backend unless the `--backend' compiler option designates a
     different backend.  *Note Compiling coNCePTuaL programs::, for
     more information.

`NCPTL_PATH'
     Specify a colon-separated list of directories in which to search
     for compiler backends.  *Note Compiling coNCePTuaL programs::, for
     more information.

   The following environment variables are honored when running a
CONCEPTUAL program (any backend):

`NCPTL_CHECKPOINT'
     Specify the minimum number of seconds between log-file checkpoints
     (default: 60).  The CONCEPTUAL run-time library buffers logged
     data in memory because CONCEPTUAL programs are not restricted to
     writing data in a top-to-bottom, left-to-right format.  The
     following program, for example, writes row 9, column 2 before
     writing row 5, column 1:

          FOR EACH i IN {1, ..., 10} {IF i IS EVEN THEN TASK 0 LOGS i
          AS "Even numbers" THEN TASK 0 LOGS i AS "All numbers"}

     Buffering data in memory enables that sort of "two-dimensional"
     logging.  However, it is not robust to computer crashes or
     uncatchable signals (e.g., `SIGKILL').  Consequently, every `LOGS'
     statement (*note Writing to a log file::) that is executed at least `NCPTL_CHECKPOINT'
     seconds after the previous one forces the CONCEPTUAL run-time
     library to write its partial data to the log file.  Specifically,
     the library flushes its partial-data buffers then rewinds the
     write pointer to the beginning of that partial data.  Hence, the
     partial data is overwritten by a later checkpoint or by the
     complete data set.

     Smaller values of `NCPTL_CHECKPOINT' provide more robustness to
     crashes and uncatchable signals.  Larger values put less stress on
     the filesystem.  As a special case, if `NCPTL_CHECKPOINT' is set to
     `0' then log-file checkpointing is disabled altogether.

`NCPTL_FAST_INIT'
     If set to `1', more quickly initialize the run-time library by
     skipping the timer calibration and measurement steps.  As a
     consequence, all timing measurements will be meaningless.  `NCPTL_FAST_INIT'
     may be useful during the development of a CONCEPTUAL program or
     compiler backend to enable shorter turnaround times.  If set to
     `0', `NCPTL_FAST_INIT' forces a thorough initialization even for
     backends that do not rely on timing measurements, for instance the `picl'
     backend (*note The picl backend::).  *Note Variables and data
     types::, for more information.

`NCPTL_LOG_DELAY'
     Artificially delay each log-file open and flush operation by a
     random number of milliseconds in the range 0...`NCPTL_LOG_DELAY'
     (default: `0').  For example, if 1000 CPUs share a single
     filesystem, an `NCPTL_LOG_DELAY' of `2000' (i.e., 2 seconds) will
     probabilistically ensure that a log-file creation request will be
     issued only once every 2000/1000 = 2 milliseconds instead of all
     at once.  `NCPTL_LOG_DELAY' is intended to help CONCEPTUAL
     programs run atop broken filesystems that are unable to handle
     large numbers of concurrent accesses--an all-too-common problem on
     large-scale workstation clusters and parallel computers in which
     hundreds or thousands of diskless compute nodes compete for access
     to the same filesystem.

`NCPTL_LOG_ONLY'
     Limit the set of processes that produce log files.  `NCPTL_LOG_ONLY'
     accepts a comma-separated list of dash-separated process ranges
     such as `0-3,12-16,24,25,32-48'.  Only processes included in the
     list produce log files.  *Note Running coNCePTuaL programs::, for
     more information.

`NCPTL_NOFORK'
     If set, inhibit the use of `fork()', `system()', `popen()', and
     other process-spawning functions.  The result is that some
     information will be omitted from the log-file prologue.  `NCPTL_NOFORK'
     is intended to be used on systems in which such functions corrupt
     messaging-layer state, hang or crash processes, or wreak other
     such havoc.


File: conceptual.info,  Node: Cache Variables,  Next: Referenced Applications,  Prev: Environment Variables,  Up: Top

Appendix D `configure' Cache Variables
**************************************

The `configure' script that is used to build CONCEPTUAL internally uses
a number of Autoconf cache variables to store configuration information
that it discovers while it runs.  If these variables are set on the `./configure
' command line, the given value will be used instead of an
automatically determined value.  This feature gives the user precise
control over many aspects of CONCEPTUAL configuration.  For example, to
prevent the CONCEPTUAL run-time library from using the `gethostbyname()'
function you can specify `ac_cv_func_gethostbyname=no' on the `./configure
' command line to convince `configure' that `gethostbyname()' does not
exist.

   The variables and descriptions in the following list were extracted
mechanically from `configure.ac' and `config.log'.  Consequently, some
variables may be missing, and some descriptions may be inaccurate or
hard to understand.

`ac_cv_func__strtoi64'
     the `_strtoi64()' function is available (`yes' or `no')

`ac_cv_func_cbrt'
     the `cbrt()' function is available (`yes' or `no')

`ac_cv_func_floor'
     the `floor()' function is available (`yes' or `no')

`ac_cv_func_fmod'
     the `fmod()' function is available (`yes' or `no')

`ac_cv_func_fork'
     the `fork()' function is available (`yes' or `no')

`ac_cv_func_fork_works'
     the `fork_works()' function is available (`yes' or `no')

`ac_cv_func_getcwd'
     the `getcwd()' function is available (`yes' or `no')

`ac_cv_func_geteuid'
     the `geteuid()' function is available (`yes' or `no')

`ac_cv_func_gethostbyname'
     the `gethostbyname()' function is available (`yes' or `no')

`ac_cv_func_getinvent'
     the `getinvent()' function is available (`yes' or `no')

`ac_cv_func_getpagesize'
     the `getpagesize()' function is available (`yes' or `no')

`ac_cv_func_getpwuid'
     the `getpwuid()' function is available (`yes' or `no')

`ac_cv_func_getrusage'
     the `getrusage()' function is available (`yes' or `no')

`ac_cv_func_getuid'
     the `getuid()' function is available (`yes' or `no')

`ac_cv_func_glob'
     the `glob()' function is available (`yes' or `no')

`ac_cv_func_ibv_get_device_list'
     the `ibv_get_device_list()' function is available (`yes' or `no')

`ac_cv_func_ibv_get_devices'
     the `ibv_get_devices()' function is available (`yes' or `no')

`ac_cv_func_kill'
     the `kill()' function is available (`yes' or `no')

`ac_cv_func_llabs'
     the `llabs()' function is available (`yes' or `no')

`ac_cv_func_nanosleep'
     the `nanosleep()' function is available (`yes' or `no')

`ac_cv_func_nearbyint'
     the `nearbyint()' function is available (`yes' or `no')

`ac_cv_func_popen'
     the `popen()' function is available (`yes' or `no')

`ac_cv_func_realpath'
     the `realpath()' function is available (`yes' or `no')

`ac_cv_func_rint'
     the `rint()' function is available (`yes' or `no')

`ac_cv_func_round'
     the `round()' function is available (`yes' or `no')

`ac_cv_func_sched_getaffinity'
     the `sched_getaffinity()' function is available (`yes' or `no')

`ac_cv_func_setitimer'
     the `setitimer()' function is available (`yes' or `no')

`ac_cv_func_sigaction'
     the `sigaction()' function is available (`yes' or `no')

`ac_cv_func_signal'
     the `signal()' function is available (`yes' or `no')

`ac_cv_func_sleep'
     the `sleep()' function is available (`yes' or `no')

`ac_cv_func_strcasestr'
     the `strcasestr()' function is available (`yes' or `no')

`ac_cv_func_strerror'
     the `strerror()' function is available (`yes' or `no')

`ac_cv_func_strsignal'
     the `strsignal()' function is available (`yes' or `no')

`ac_cv_func_strtok'
     the `strtok()' function is available (`yes' or `no')

`ac_cv_func_strtoll'
     the `strtoll()' function is available (`yes' or `no')

`ac_cv_func_strtoq'
     the `strtoq()' function is available (`yes' or `no')

`ac_cv_func_sysconf'
     the `sysconf()' function is available (`yes' or `no')

`ac_cv_func_sysctl'
     the `sysctl()' function is available (`yes' or `no')

`ac_cv_func_sysmp'
     the `sysmp()' function is available (`yes' or `no')

`ac_cv_func_syssgi'
     the `syssgi()' function is available (`yes' or `no')

`ac_cv_func_time'
     the `time()' function is available (`yes' or `no')

`ac_cv_func_trunc'
     the `trunc()' function is available (`yes' or `no')

`ac_cv_func_uname'
     the `uname()' function is available (`yes' or `no')

`ac_cv_func_vfork'
     the `vfork()' function is available (`yes' or `no')

`ac_cv_func_vfork_works'
     the `vfork_works()' function is available (`yes' or `no')

`ac_cv_func_vfprintf'
     the `vfprintf()' function is available (`yes' or `no')

`ac_cv_func_vsnprintf'
     the `vsnprintf()' function is available (`yes' or `no')

`ac_cv_func_vsprintf'
     the `vsprintf()' function is available (`yes' or `no')

`ac_cv_header_bglpersonality_h'
     the `bglpersonality.h' header file is available (`yes' or `no')

`ac_cv_header_cf_h'
     the `cf.h' header file is available (`yes' or `no')

`ac_cv_header_common_bgp_personality_h'
     the `common/bgp_personality.h' header file is available (`yes' or
     `no')

`ac_cv_header_dlfcn_h'
     the `dlfcn.h' header file is available (`yes' or `no')

`ac_cv_header_errno_h'
     the `errno.h' header file is available (`yes' or `no')

`ac_cv_header_glob_h'
     the `glob.h' header file is available (`yes' or `no')

`ac_cv_header_ieeefp_h'
     the `ieeefp.h' header file is available (`yes' or `no')

`ac_cv_header_infiniband_verbs_h'
     the `infiniband/verbs.h' header file is available (`yes' or `no')

`ac_cv_header_inttypes_h'
     the `inttypes.h' header file is available (`yes' or `no')

`ac_cv_header_invent_h'
     the `invent.h' header file is available (`yes' or `no')

`ac_cv_header_libhal_h'
     the `libhal.h' header file is available (`yes' or `no')

`ac_cv_header_machine_hal_sysinfo_h'
     the `machine/hal_sysinfo.h' header file is available (`yes' or
     `no')

`ac_cv_header_memory_h'
     the `memory.h' header file is available (`yes' or `no')

`ac_cv_header_mpi_h'
     the `mpi.h' header file is available (`yes' or `no')

`ac_cv_header_netdb_h'
     the `netdb.h' header file is available (`yes' or `no')

`ac_cv_header_odmi_h'
     the `odmi.h' header file is available (`yes' or `no')

`ac_cv_header_papi_h'
     the `papi.h' header file is available (`yes' or `no')

`ac_cv_header_pci_pci_h'
     the `pci/pci.h' header file is available (`yes' or `no')

`ac_cv_header_popt_h'
     the `popt.h' header file is available (`yes' or `no')

`ac_cv_header_pwd_h'
     the `pwd.h' header file is available (`yes' or `no')

`ac_cv_header_rms_rmscall_h'
     the `rms/rmscall.h' header file is available (`yes' or `no')

`ac_cv_header_sched_h'
     the `sched.h' header file is available (`yes' or `no')

`ac_cv_header_signal_h'
     the `signal.h' header file is available (`yes' or `no')

`ac_cv_header_stdint_h'
     the `stdint.h' header file is available (`yes' or `no')

`ac_cv_header_stdlib_h'
     the `stdlib.h' header file is available (`yes' or `no')

`ac_cv_header_string_h'
     the `string.h' header file is available (`yes' or `no')

`ac_cv_header_strings_h'
     the `strings.h' header file is available (`yes' or `no')

`ac_cv_header_sys_cfgodm_h'
     the `sys/cfgodm.h' header file is available (`yes' or `no')

`ac_cv_header_sys_mman_h'
     the `sys/mman.h' header file is available (`yes' or `no')

`ac_cv_header_sys_param_h'
     the `sys/param.h' header file is available (`yes' or `no')

`ac_cv_header_sys_resource_h'
     the `sys/resource.h' header file is available (`yes' or `no')

`ac_cv_header_sys_select_h'
     the `sys/select.h' header file is available (`yes' or `no')

`ac_cv_header_sys_stat_h'
     the `sys/stat.h' header file is available (`yes' or `no')

`ac_cv_header_sys_sysctl_h'
     the `sys/sysctl.h' header file is available (`yes' or `no')

`ac_cv_header_sys_sysinfo_h'
     the `sys/sysinfo.h' header file is available (`yes' or `no')

`ac_cv_header_sys_sysmp_h'
     the `sys/sysmp.h' header file is available (`yes' or `no')

`ac_cv_header_sys_syssgi_h'
     the `sys/syssgi.h' header file is available (`yes' or `no')

`ac_cv_header_sys_time_h'
     the `sys/time.h' header file is available (`yes' or `no')

`ac_cv_header_sys_types_h'
     the `sys/types.h' header file is available (`yes' or `no')

`ac_cv_header_sys_utsname_h'
     the `sys/utsname.h' header file is available (`yes' or `no')

`ac_cv_header_sys_wait_h'
     the `sys/wait.h' header file is available (`yes' or `no')

`ac_cv_header_time_h'
     the `time.h' header file is available (`yes' or `no')

`ac_cv_header_unistd_h'
     the `unistd.h' header file is available (`yes' or `no')

`ac_cv_header_uuid_uuid_h'
     the `uuid/uuid.h' header file is available (`yes' or `no')

`ac_cv_header_vfork_h'
     the `vfork.h' header file is available (`yes' or `no')

`ac_cv_header_windows_h'
     the `windows.h' header file is available (`yes' or `no')

`ac_cv_lib_ibverbs_ibv_query_device'
     `libibverbs.a' contains a function called `ibv_query_device()'
     (`yes' or `no')

`ac_cv_lib_lipr_IprStart'
     `liblipr.a' contains a function called `IprStart()' (`yes' or `no')

`ac_cv_lib_m_fmod'
     `libm.a' contains a function called `fmod()' (`yes' or `no')

`ac_cv_lib_papi_PAPI_get_real_usec'
     `libpapi.a' contains a function called `PAPI_get_real_usec()'
     (`yes' or `no')

`ac_cv_lib_perfctr_main'
     `libperfctr.a' contains a function called `main()' (`yes' or `no')

`ac_cv_lib_popt_poptGetContext'
     `libpopt.a' contains a function called `poptGetContext()' (`yes'
     or `no')

`ac_cv_lib_sysfs_sysfs_open_class'
     `libsysfs.a' contains a function called `sysfs_open_class()'
     (`yes' or `no')

`ac_cv_lib_uuid_uuid_unparse'
     `libuuid.a' contains a function called `uuid_unparse()' (`yes' or
     `no')

`ac_cv_member_struct_CuAt_name'
     the `CuAt' `struct' contains a field called `name' (`yes' or `no')

`ac_cv_member_struct_hostent_h_name'
     the `hostent' `struct' contains a field called `h_name' (`yes' or
     `no')

`ac_cv_path_ASY'
     the fully qualified filename for `asy'

`ac_cv_path_DOT'
     the fully qualified filename for `dot'

`ac_cv_path_EGREP'
     the fully qualified filename for `egrep'

`ac_cv_path_FGREP'
     the fully qualified filename for `fgrep'

`ac_cv_path_GIMP'
     the fully qualified filename for `gimp'

`ac_cv_path_GPERF'
     the fully qualified filename for `gperf'

`ac_cv_path_GREP'
     the fully qualified filename for `grep'

`ac_cv_path_GS'
     the fully qualified filename for `gs'

`ac_cv_path_HTMLTIDY'
     the fully qualified filename for `htmltidy'

`ac_cv_path_JYTHONC'
     the fully qualified filename for `jythonc'

`ac_cv_path_LDD'
     the fully qualified filename for `ldd'

`ac_cv_path_PERL'
     the fully qualified filename for `perl'

`ac_cv_path_PYTHON'
     the fully qualified filename for `python'

`ac_cv_path_SED'
     the fully qualified filename for `sed'

`ac_cv_path_SWIG'
     the fully qualified filename for `swig'

`ac_cv_prog_AWK'
     command line for running `awk'

`ac_cv_prog_CPP'
     command line for running `cpp'

`ac_cv_prog_EMACS'
     command line for running `emacs'

`ac_cv_prog_INDENT'
     command line for running `indent'

`ac_cv_prog_JAR'
     command line for running `jar'

`ac_cv_prog_JAVAC'
     command line for running `javac'

`ac_cv_prog_LATEX'
     command line for running `latex'

`ac_cv_prog_MAKE'
     command line for running `make'

`ac_cv_prog_MPICC'
     command line for running `mpicc'

`ac_cv_prog_MSGDIGEST'
     command line for running `msgdigest'

`ac_cv_prog_PDFTEX'
     command line for running `pdftex'

`ac_cv_prog_PKGCONFIG'
     command line for running `pkgconfig'

`ac_cv_prog_TEX'
     command line for running `tex'

`ac_cv_search_MPI_Init'
     linker flags/libraries needed to use the `MPI_Init()' function or
     `none required'

`ac_cv_search_clock_gettime'
     linker flags/libraries needed to use the `clock_gettime()'
     function or `none required'

`ac_cv_search_kstat_data_lookup'
     linker flags/libraries needed to use the `kstat_data_lookup()'
     function or `none required'

`ac_cv_search_nanosleep'
     linker flags/libraries needed to use the `nanosleep()' function or
     `none required'

`ac_cv_search_pci_scan_bus'
     linker flags/libraries needed to use the `pci_scan_bus()' function
     or `none required'

`ac_cv_sizeof_long_double'
     size in bytes of the `long double' datatype

`ac_cv_sizeof_u_int128_t'
     size in bytes of the `u_int128_t' datatype

`ac_cv_sizeof_unsigned___int128'
     size in bytes of the `unsigned __int128' datatype

`ac_cv_sizeof_unsigned_long_long_long'
     size in bytes of the `unsigned long long long' datatype

`ac_cv_type_int64_t'
     the `int64_t' datatype exists (`yes' or `no')

`ac_cv_type_pid_t'
     the `pid_t' datatype exists (`yes' or `no')

`ac_cv_type_signal'
     the `signal' datatype exists (`yes' or `no')

`ac_cv_type_ssize_t'
     the `ssize_t' datatype exists (`yes' or `no')

`ac_cv_type_uid_t'
     the `uid_t' datatype exists (`yes' or `no')

`ac_cv_type_uint128_t'
     the `uint128_t' datatype exists (`yes' or `no')

`ac_cv_type_uint16_t'
     the `uint16_t' datatype exists (`yes' or `no')

`ac_cv_type_uint32_t'
     the `uint32_t' datatype exists (`yes' or `no')

`ac_cv_type_uint64_t'
     the `uint64_t' datatype exists (`yes' or `no')

`ac_cv_type_uint8_t'
     the `uint8_t' datatype exists (`yes' or `no')

`ac_cv_type_uintptr_t'
     the `uintptr_t' datatype exists (`yes' or `no')

`ax_cv_const_nics_valid'
     `$NICS' is a valid printf conversion specifier for `ncptl_int'

`ax_cv_decl_double_smallest'
     a definition of the largest double value

`ax_cv_decl_suffix_valid'
     `$NCPTL_INT_SUFFIX' is a valid suffix for an `ncptl_int' constant

`ax_cv_file_cray_xt_nid'
     `_my_pnid' is definable from a file

`ax_cv_func_mpicc_requires_libm'
     `$MPICC' wants the math library to be linked explicitly

`ax_cv_func_round_works'
     `round' is likely to work

`ax_cv_prog_cc_ansic'
     `$CC' supports some basic ANSI C features

`ax_cv_prog_eval_break_works'
     `eval break' successfully breaks out of a loop

`ax_cv_prog_gperf_recent'
     `gperf' is sufficiently recent

`ax_cv_prog_jar_e'
     `$JAR' supports `-e'

`ax_cv_prog_ld_interp'
     we can store symbols in `.interp'

`ax_cv_prog_ld_so'
     the name of the dynamic linker

`ax_cv_prog_make_RM'
     `$am_make' predefines \$(RM)

`ax_cv_prog_make_RM_qeq'
     `$am_make' supports `?='

`ax_cv_prog_perl_logextract'
     `$PERL' can run `ncptl-logextract'

`ax_cv_prog_swig_version'
     `swig' version number

`ax_cv_prog_swig_works'
     `swig' works

`ax_cv_sys_null_device'
     the null device is called

`ax_cv_type_MT_STATE_size'
     number of words of random-number-generator state

`ax_cv_type_long_big_enough'
     a long can hold both an `int64_t' and an `ncptl_int' type

`ax_cv_type_ncptl_int_max'
     we can find the maximum `ncptl_int' value

`ax_cv_type_ncptl_int_min'
     we can find the minimum `ncptl_int' value

`ax_cv_var___cpu_mhz'
     `__cpu_mhz' is defined

`ax_cv_var__my_pnid'
     `_my_pnid' is defined


File: conceptual.info,  Node: Referenced Applications,  Next: License,  Prev: Cache Variables,  Up: Top

Referenced Applications
***********************

A number of third-party applications are mentioned throughout this
document.  For your convenience, the following list states the URL of
each application's home page.

a2ps
     `http://www.gnu.org/software/a2ps/'

Dimemas
     See Paraver.

dot
     See Graphviz.

Emacs
     `http://www.gnu.org/software/emacs/'

Extrae
     See Paraver.

Environment Modules
     `http://modules.sourceforge.net/'

GeSHi
     `http://qbnz.com/highlighter/'

Graphviz
     `http://www.graphviz.org/'

LaTeX
     `http://www.latex-project.org/'

LibSea
     `http://www.caida.org/tools/visualization/libsea/'

Mediawiki
     `http://www.mediawiki.org/'

MPICL
     `http://www.csm.ornl.gov/picl/'

ParaGraph
     `http://www.csar.uiuc.edu/software/paragraph/'

Paraver
     `http://www.bsc.es/paraver'

PICL
     See MPICL.

pkg-config
     `http://pkg-config.freedesktop.org/wiki/'

PSTricks
     `http://www.tug.org/applications/PSTricks/'

Python
     `http://www.python.org/'

SLOCCount
     `http://www.dwheeler.com/sloccount/'

Source-highlight
     `http://www.gnu.org/software/src-highlite/'

TeX
     See LaTeX.

Vim
     `http://www.vim.org/'

Walrus
     `http://www.caida.org/tools/visualization/walrus/'


File: conceptual.info,  Node: License,  Next: Index,  Prev: Referenced Applications,  Up: Top

License
*******

Copyright (C) 2012, Los Alamos National Security, LLC
All rights reserved.


   Copyright (2012).  Los Alamos National Security, LLC.  This software
was produced under U.S. Government contract DE-AC52-06NA25396 for Los
Alamos National Laboratory (LANL), which is operated by Los Alamos
National Security, LLC (LANS) for the U.S. Department of Energy. The
U.S. Government has rights to use, reproduce, and distribute this
software.  NEITHER THE GOVERNMENT NOR LANS MAKES ANY WARRANTY, EXPRESS
OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE. If
software is modified to produce derivative works, such modified
software should be clearly marked, so as not to confuse it with the
version available from LANL.

   Additionally, redistribution and use in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

   * Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

   * Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in
       the documentation and/or other materials provided with the
     distribution.

   * Neither the name of Los Alamos National Security, LLC, Los Alamos
       National Laboratory, the U.S. Government, nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY LANS AND CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL LANS OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


Summary
.......

This is a BSD license with the additional proviso that modified
versions of CONCEPTUAL must indicate that they are, in fact, modified.

